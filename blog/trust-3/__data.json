{"type":"data","nodes":[null,{"type":"data","data":[{"id":1,"content":2,"html":3,"title":4,"date":5,"tags":6},"trust-3","{\n\t\"title\": \"Parsing Terraria's .wld Files (trust pt. 3)\",\n\t\"date\": 1708364642136,\n\t\"tags\": [\"trust\", \"rust\", \"binary\"]\n}\n---\n\nWelcome to part three of my journey through writing a Terraria game server in Rust. Since [part 2](/blog/trust-2), I've gotten the client to be able to enter a password and begin to connect.\n\n## Protocol Recap\n\nWhen a player first connects, they send the version identifier using a type 1 packet. It is a string with the length annotated by the first byte. `5265727261726961323739` is `Terraria279` in ASCII.\n\n```\n[c->s]: (1) 0b5465727261726961323739\n```\n\nIf the server has a password, it sends a type 37 packet with no data to challenge the client.\n\n```\n[s->c]: (37) \n```\n\nThe client is prompted and sends back the password. This is once again a byte-annotated string. `70617373776f7264` is `password` in ASCII.\n\n```\n[c->s]: (38) 0870617373776f7264\n```\n\nIf the password is incorrect, the server can send back text using a type 2 packet to refuse the connection. If the password is correct or there is no password, the server sends the player a type 3 packet. The first byte represents the player's ID on the server. The second is a boolean that is always set to false.\n\n```\n[s->c]: (3) 0000\n```\n\nAfter this, the client begins sending a whole bunch of data about their player. First is type 4, which represents the player's character details.\n\n```\n[c->s]: (4) 000000036c6f6c00000000d75a37ff7d5a695a4bafa58ca0b4d7ffe6afa0693c001000\n```\n\nThe packet is represented by the following struct. For more information on what each bit in the flags signifies, check the [code comments](https://github.com/xDimGG/trust/blob/48271674c6bb3636baf524f058809722af0a64c9/src/network/messages.rs#L105-L129).\n\n```rs\n/// 4 \u003C->\nPlayerDetails {\n\tclient_id: u8,\n\tskin_variant: u8,\n\thair: u8,\n\tname: String,\n\thair_dye: u8,\n\thide_accessory: u16,\n\thide_misc: u8,\n\thair_color: RGB,\n\tskin_color: RGB,\n\teye_color: RGB,\n\tshirt_color: RGB,\n\tundershirt_color: RGB,\n\tpants_color: RGB,\n\tshoe_color: RGB,\n\tflags_1: u8,\n\tflags_2: u8,\n\tflags_3: u8,\n},\n```\n\nThe Terraria server does a couple of checks here.\n\n1. The character name does not match someone else's name on the server.\n2. The name is no more than 20 characters long.\n3. The name is not empty (`name != \"\"`).\n4. The player and world are both [journey mode](https://terraria.fandom.com/wiki/Journey_Mode) or both not journey mode.\n\nIf everything is good, the player's character details are emitted to all the other players in the server.\n\nNext up is the player's UUID. This is again just a string. `38663037383932632d663363302d346433332d613966392d616435313932356462393532` represents `8f07892c-f3c0-4d33-a9f9-ad51925db952` in ASCII. The server doesn't actually have to do anything with this.\n\n```\n[c->s]: (68) 2438663037383932632d663363302d346433332d613966392d616435313932356462393532\n```\n\nNext is the player's health and mana. Only the health has to be broadcasted to other players.\n\n```\n[c->s]: (16) 0064006400\n[c->s]: (42) 0014001400\n```\n\n```rs\n/// 16 \u003C->\nPlayerHealth {\n\tclient_id: u8,\n\tcurrent: i16,\n\tmaximum: i16,\n},\n\n/// 42 \u003C-\nPlayerMana {\n\tclient_id: u8,\n\tcurrent: i16,\n\tmaximum: i16,\n},\n```\n\nNext is any buffs the player has active. This gets broadcasted.\n\n```\n[c->s]: (50) 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n```\n\n```rs\n/// 50 \u003C->\nPlayerBuffs {\n\tclient_id: u8,\n\tbuffs: [u16; MAX_BUFFS],\n},\n```\n\nNext is the player's active loadout. As of Terraria 1.4.4, player's can have different armor loadouts so this packet notifies the server of which loadout the player has active and what accessories to hide. This gets broadcasted.\n\n```\n[c->s]: (147) 00000000\n```\n\n```rs\n/// 147 \u003C->\nPlayerLoadout {\n\tclient_id: u8,\n\tindex: u8,\n\thide_accessory: u16,\n},\n```\n\nNext, the player sends a whole bunch of type 5 packets. It represents each item the player has on their character. This includes not just inventory items, but also armor, ammo, other loadouts, and more. This gets broadcasted.\n\n```rs\n/// 5 \u003C->\nPlayerInventorySlot {\n\tclient_id: u8,\n\tslot_id: i16,\n\tamount: i16,\n\tprefix: u8,\n\titem_id: i16,\n},\n```\n\nFinally, the player sends an empty packet with type 6, which triggers the server to send metadata about the world. After that is received, the client send a type 8 packet which makes the server send back even more world data, which includes some tile data. All the packets until now have been quite simple to implement, but now the client is expecting world data and our program doesn't hold a world.\n\n## Parsing .wld Files\n\nIn order to get some world data, we should probably parse the .wld file that Terraria store's world data in. I googled around a bit and it seems that others have already figured out, documented, and written parsers for it in the past. Notably, there is [Terraria Map Editor](https://github.com/TEdit/Terraria-Map-Editor), which provides a UI for editing Terraria world files and updating lots of tiles at once with Microsoft Paint-like tools. It's a neat tool and could be a good reference point to work off. However, after exploring the decompiled code some more, there is a `WorldFile` class which contains a `LoadWorld` method. It's actually not that hard to read, so I'm just going to work off that.\n\nFor starters, where does Terraria store `.wld` file? On Windows, it's in `Documents > My Games > Terraria > Worlds`. On macOS, it's in `~/Library/Application Support/Terraria/Worlds`. Let's get the contents of the file and pass it to the reader that was created in [part 2](/blog/trust-2).\n\n```rs\nlet contents = fs::read(\"Courtyard_of_Grasshoppers.wld\").unwrap();\nlet mut reader = Reader::new(contents.as_slice());\n```\n\nIn the decompiled code, the first thing done on the reader is ReadInt32(), and `WorldFile._versionNumber` is set to that number. Similarly, in our code, we can write the following.\n\n```rs\nlet version = reader.read_i32();\nprintln!(\"File version: {}\", version);\n```\n\nRunning this, we get:\n\n```\nFile version: 279\n```\n\nNice. It's the same as the Terraria version from earlier. At this point, there is a branch in the code. Before version 88, we call `WorldFile.LoadWorld_Version1_Old_BeforeRelease88`. Starting from version 88, `WorldFile.LoadWorld_Version2` is called. Let's go ahead and just implement `WorldFile.LoadWorld_Version2`. We can always support older versions later. Within `LoadWorld_Version2`, the first function called is `LoadFileFormatHeader`, which looks like so.\n\n```cs\npublic static bool LoadFileFormatHeader(BinaryReader reader, out bool[] importance, out int[] positions) {\n\timportance = (bool[]) null;\n\tpositions = (int[]) null;\n\tif ((WorldFile._versionNumber = reader.ReadInt32()) >= 135) {\n\t\ttry {\n\t\t\tMain.WorldFileMetadata = FileMetadata.Read(reader, FileType.World);\n\t\t}\n\t\tcatch (FormatException ex) {\n\t\t\tConsole.WriteLine(Language.GetTextValue(\"Error.UnableToLoadWorld\"));\n\t\t\tConsole.WriteLine((object) ex);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t\tMain.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);\n\tshort length1 = reader.ReadInt16();\n\tpositions = new int[(int) length1];\n\tfor (int index = 0; index \u003C (int) length1; ++index)\n\t\tpositions[index] = reader.ReadInt32();\n\tushort length2 = reader.ReadUInt16();\n\timportance = new bool[(int) length2];\n\tbyte num1 = 0;\n\tbyte num2 = 128;\n\tfor (int index = 0; index \u003C (int) length2; ++index) {\n\t\tif (num2 == (byte) 128) {\n\t\t\tnum1 = reader.ReadByte();\n\t\t\tnum2 = (byte) 1;\n\t\t}\n\t\telse\n\t\t\tnum2 \u003C\u003C= 1;\n\t\tif (((int) num1 & (int) num2) == (int) num2)\n\t\t\timportance[index] = true;\n\t}\n\treturn true;\n}\n```\n\nOk, so a call to `FileMetadata.Read` is made. We can navigate to `FileMetadata` and find that the `Read` method looks like this.\n\n```cs\nprivate void Read(BinaryReader reader) {\n\tlong num1 = (long) reader.ReadUInt64();\n\tif ((num1 & 72057594037927935L) != 27981915666277746L)\n\t\tthrow new FormatException(\"Expected Re-Logic file format.\");\n\tbyte num2 = (byte) ((ulong) num1 >> 56 & (ulong) byte.MaxValue);\n\tFileType fileType = FileType.None;\n\tFileType[] values = (FileType[]) Enum.GetValues(typeof (FileType));\n\tfor (int index = 0; index \u003C values.Length; ++index) {\n\t\tif (values[index] == (FileType) num2) {\n\t\t\tfileType = values[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\tthis.Type = fileType != FileType.None ? fileType : throw new FormatException(\"Found invalid file type.\");\n\tthis.Revision = reader.ReadUInt32();\n\tthis.IsFavorite = ((long) reader.ReadUInt64() & 1L) == 1L;\n}\n```\n\nIf we convert `72057594037927935` to binary, it's just 56 `1`s. If we convert `27981915666277746` to hexadecimal and use an online hex to ASCII tool, we get `cigoler`. That's `relogic` backwards. `Re-Logic` is the name of the company that made Terraria. This seems to be a magic number for Re-Logic files. The reason it's backwards is that we are using little endian encoding. Let's go ahead and add a check for this magic number.\n\n```rs\nlet magic = reader.read_bytes(7);\nif magic != \"relogic\".as_bytes() {\n\tpanic!(\"not a relogic file\")\n}\n```\n\nAfter this, we can read the `fileType` as 1 byte.\n```rs\nlet file_type = reader.read_byte()?;\n```\n\nRunning the code, we get this.\n```\nFile type: 2\n```\n\nThe code corresponds to this enum.\n\n```cs\npublic enum FileType : byte {\n\tNone,\n\tMap,\n\tWorld,\n\tPlayer,\n}\n```\n\nSince we are dealing with a world file, the value 2 makes sense. Next is `this.Revision = reader.ReadUInt32();` and `this.IsFavorite = ((long) reader.ReadUInt64() & 1L) == 1L;`.\n\n```rs\nlet revision = reader.read_u32();\nprintln!(\"Revision: {}\", revision);\nlet favorite = reader.read_u64() & 1 == 1;\nprintln!(\"Is favorite: {}\", favorite);\n```\n\nNow, we get this output.\n\n```\nFile version: 279\nFile type: 2\nRevision: 3\nIs favorite: false\n```\n\nLooks pretty good. Back to the parent function, `LoadFileFormatHeader`, we read the positions like so.\n\n```cs\nshort length1 = reader.ReadInt16();\npositions = new int[(int) length1];\nfor (int index = 0; index \u003C (int) length1; ++index)\n\tpositions[index] = reader.ReadInt32();\n```\n\nLet's go ahead and do that in Rust.\n\n```rs\nlet mut positions = Vec::with_capacity(reader.read_i16() as usize);\nfor _ in 0..positions.capacity() {\n\tpositions.push(reader.read_i32());\n}\nprintln!(\"File positions: {:?}\", positions);\n```\n\nWith this in place, we get this in our console:\n\n```\nFile positions: [159, 3413, 6618450, 6656473, 6656475, 6656542, 6656546, 6656550, 6656554, 6656576, 6656607]\n```\n\nWhat the Terraria world parser does is that after reading each section of data, it checks that the cursor is at the correct position before proceeding. This turns out to be _really_ useful when reading the file myself. It prevents me from accidentally reading loads of garbage without realizing and provides checkpoints for me as I'm writing the parser. If we parsed some block but the cursor doesn't match, it's a sign that we did something wrong.\n\nNext up is the code for getting the \"importance\" of things. At this point it's not clear what this is for, but becomes apparent when reading the tiles. \"important\" tiles contain extra data.\n\n```rs\nlet mut importance = vec![false; reader.read_u16() as usize];\nlet mut byte = 0;\nlet mut mask = 128;\nfor i in &mut importance {\n\tif mask == 128 {\n\t\tbyte = reader.read_byte();\n\t\tmask = 1;\n\t} else {\n\t\tmask \u003C\u003C= 1;\n\t}\n\n\tif (byte & mask) == mask {\n\t\t*i = true;\n\t}\n}\nprintln!(\"Importance count: {}\", importance.len());\n```\n\nAll that this code is doing is reading the individual bits of the reader as booleans. Running this spits out:\n\n```\nImportance count: 693\n```\n\nWe may also check our `reader.cur` at this point and see that it is `159`, which matches the first position in our positions array.\n\nYou can imagine how the rest of this goes. It's basically just writing a bunch of [structs and enums](https://github.com/xDimGG/trust/blob/main/src/world/types.rs) and lots of calls to the [reader](https://github.com/xDimGG/trust/blob/main/src/world/reader.rs). Writing it all out in a blog post would take a very long time and be quite boring. I'll just tell you the most interesting part.\n\n## Parsing Strings, Revisited\n\nOnce I finished writing the parser, my world file was working just fine. However, I tried downloading someone else's world file and got an error from `str::from_utf8`. For some reason, the string wasn't being parsed correctly. At first, I thought that maybe Terraria files don't use UTF-8 strings, so I poked around the decompiled code a bit and couldn't figure out what was wrong. I tried checking the C# documentation for information on how [WriteString](https://learn.microsoft.com/en-us/uwp/api/windows.storage.streams.datawriter.writestring?view=winrt-22621) encodes the string, however, the only thing the page says is `Writes a string value to the output stream.`. Very helpful, Microsoft. I walked away from my computer a bit and that's when it hit me that maybe the strings I'm reading are just too long. Up to this point, I parsed strings by reading the first byte as the length and the rest as the string, which means that I could only support strings of length less than 256. As it turns out, this is not what the C# `DataWriter` does. In fact, it uses a varying-length integer, similar to UTF-8. What this means is that the first bit represents whether there is still more data about the length.\n\nSuppose we have a string of length 64. Its length will just be encoded as `01000000`. If our string's length is 300, which is `100101100` in binary. The first byte will contain the least seven bits of the number, `0101100`. The most significant bit will be set to `1` to signify that there are still more bits to read. The second byte will contain the remaining bits, `10`, with the most significant bit set to `0` to signify that there are no more bits. In the end, our `300` becomes `10101100 00000010`. Two bytes. Until now, I've treated the string length as just 1 byte, which means we actually couldn't support any string whose length is greater than 127, since the first bit is reserved.\n\nOur updated `read_string` function looks like this now.\n\n```rs\npub fn read_length(&mut self) -> usize {\n\tlet mut length = self.read_byte() as usize;\n\tlet mut shift = 7;\n\twhile length & (1 \u003C\u003C shift) != 0 {\n\t\tlength &= !(1 \u003C\u003C shift);\n\t\tlength |= (self.read_byte() as usize) \u003C\u003C shift;\n\t\tshift += 7;\n\t}\n\n\tlength\n}\n\npub fn read_string(&mut self) -> String {\n\tlet length = self.read_length();\n\tstd::str::from_utf8(self.read_bytes(length)).unwrap_or(\"\").to_string()\n}\n```\n\nOn the write side, it looks like this.\n\n```rs\npub fn write_length(&mut self, mut len: usize) {\n\twhile len >= (1 \u003C\u003C 7) {\n\t\tself.write_byte((len & 0b1111111) as u8 | (1 \u003C\u003C 7));\n\t\tlen >>= 7;\n\t}\n\n\tself.write_byte(len as u8)\n}\n\npub fn write_string(&mut self, string: String) {\n\tself.write_length(string.len());\n\tself.write_bytes(string.as_bytes().to_vec())\n}\n```\n\n## Up and Running\n\nAnyway, with that figured out, the World file parser is done! It has an annoyingly large number of fields, but it works. This means that now, we can begin to send world data to the player.\n\n![connecting to trust server](/trust-3.png)\n\nIt works! For some reason, Re-Logic decided to make world tile packets zlib-compressed, which meant I had to dig into [DotNetZip](https://github.com/DinoChiesa/DotNetZip) to figure out exactly what parameters were being used. It turns out that the way Terraria uses the library ends up removing the zlib header and trailing checksum. It was quite tricky to figure out, but using the proxy made it easier. As a bonus, I added this to the proxy:\n\n```py\ndisp_data = data[1:]\nif data[0] == 10:\n\tdisp_data = zlib.decompress(disp_data, wbits=-15)\nprint(f'{prefix} ({data[0]}) {disp_data.hex()}')\n```\n\nwhich decompresses any packets containing tile data.\n\n## Closing Notes\n\nSo, we have our world and we can move around in it. We can even break blocks, but breaking stuff doesn't drop anything. In fact, everything we're doing is only on the client side. In order to support block-breaking and whatnot, we'll need to mutate the world object. We'll also have to be able to save the world, which means doing everything we just did in reverse. We've come a lot further than what I though would be possible! Everything from here should be smooth sailing. See you again in part 4!\n","\u003Cp>Welcome to part three of my journey through writing a Terraria game server in Rust. Since \u003Ca href=\"/blog/trust-2\">part 2\u003C/a>, I&#39;ve gotten the client to be able to enter a password and begin to connect.\u003C/p>\n\u003Ch2>Protocol Recap\u003C/h2>\n\u003Cp>When a player first connects, they send the version identifier using a type 1 packet. It is a string with the length annotated by the first byte. \u003Ccode>5265727261726961323739\u003C/code> is \u003Ccode>Terraria279\u003C/code> in ASCII.\u003C/p>\n\u003Cpre>\u003Ccode>[c-&gt;s]: (1) 0b5465727261726961323739\n\u003C/code>\u003C/pre>\u003Cp>If the server has a password, it sends a type 37 packet with no data to challenge the client.\u003C/p>\n\u003Cpre>\u003Ccode>[s-&gt;c]: (37) \n\u003C/code>\u003C/pre>\u003Cp>The client is prompted and sends back the password. This is once again a byte-annotated string. \u003Ccode>70617373776f7264\u003C/code> is \u003Ccode>password\u003C/code> in ASCII.\u003C/p>\n\u003Cpre>\u003Ccode>[c-&gt;s]: (38) 0870617373776f7264\n\u003C/code>\u003C/pre>\u003Cp>If the password is incorrect, the server can send back text using a type 2 packet to refuse the connection. If the password is correct or there is no password, the server sends the player a type 3 packet. The first byte represents the player&#39;s ID on the server. The second is a boolean that is always set to false.\u003C/p>\n\u003Cpre>\u003Ccode>[s-&gt;c]: (3) 0000\n\u003C/code>\u003C/pre>\u003Cp>After this, the client begins sending a whole bunch of data about their player. First is type 4, which represents the player&#39;s character details.\u003C/p>\n\u003Cpre>\u003Ccode>[c-&gt;s]: (4) 000000036c6f6c00000000d75a37ff7d5a695a4bafa58ca0b4d7ffe6afa0693c001000\n\u003C/code>\u003C/pre>\u003Cp>The packet is represented by the following struct. For more information on what each bit in the flags signifies, check the \u003Ca href=\"https://github.com/xDimGG/trust/blob/48271674c6bb3636baf524f058809722af0a64c9/src/network/messages.rs#L105-L129\">code comments\u003C/a>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-comment\">/// 4 &lt;-&gt;\u003C/span>\nPlayerDetails {\n    client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    skin_variant: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    hair: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    name: \u003Cspan class=\"hljs-type\">String\u003C/span>,\n    hair_dye: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    hide_accessory: \u003Cspan class=\"hljs-type\">u16\u003C/span>,\n    hide_misc: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    hair_color: RGB,\n    skin_color: RGB,\n    eye_color: RGB,\n    shirt_color: RGB,\n    undershirt_color: RGB,\n    pants_color: RGB,\n    shoe_color: RGB,\n    flags_1: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    flags_2: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    flags_3: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n},\n\u003C/code>\u003C/pre>\u003Cp>The Terraria server does a couple of checks here.\u003C/p>\n\u003Col>\n\u003Cli>The character name does not match someone else&#39;s name on the server.\u003C/li>\n\u003Cli>The name is no more than 20 characters long.\u003C/li>\n\u003Cli>The name is not empty (\u003Ccode>name != &quot;&quot;\u003C/code>).\u003C/li>\n\u003Cli>The player and world are both \u003Ca href=\"https://terraria.fandom.com/wiki/Journey_Mode\">journey mode\u003C/a> or both not journey mode.\u003C/li>\n\u003C/ol>\n\u003Cp>If everything is good, the player&#39;s character details are emitted to all the other players in the server.\u003C/p>\n\u003Cp>Next up is the player&#39;s UUID. This is again just a string. \u003Ccode>38663037383932632d663363302d346433332d613966392d616435313932356462393532\u003C/code> represents \u003Ccode>8f07892c-f3c0-4d33-a9f9-ad51925db952\u003C/code> in ASCII. The server doesn&#39;t actually have to do anything with this.\u003C/p>\n\u003Cpre>\u003Ccode>[c-&gt;s]: (68) 2438663037383932632d663363302d346433332d613966392d616435313932356462393532\n\u003C/code>\u003C/pre>\u003Cp>Next is the player&#39;s health and mana. Only the health has to be broadcasted to other players.\u003C/p>\n\u003Cpre>\u003Ccode>[c-&gt;s]: (16) 0064006400\n[c-&gt;s]: (42) 0014001400\n\u003C/code>\u003C/pre>\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-comment\">/// 16 &lt;-&gt;\u003C/span>\nPlayerHealth {\n    client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    current: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n    maximum: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n},\n\n\u003Cspan class=\"hljs-comment\">/// 42 &lt;-\u003C/span>\nPlayerMana {\n    client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    current: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n    maximum: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n},\n\u003C/code>\u003C/pre>\u003Cp>Next is any buffs the player has active. This gets broadcasted.\u003C/p>\n\u003Cpre>\u003Ccode>[c-&gt;s]: (50) 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\u003C/code>\u003C/pre>\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-comment\">/// 50 &lt;-&gt;\u003C/span>\nPlayerBuffs {\n    client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    buffs: [\u003Cspan class=\"hljs-type\">u16\u003C/span>; MAX_BUFFS],\n},\n\u003C/code>\u003C/pre>\u003Cp>Next is the player&#39;s active loadout. As of Terraria 1.4.4, player&#39;s can have different armor loadouts so this packet notifies the server of which loadout the player has active and what accessories to hide. This gets broadcasted.\u003C/p>\n\u003Cpre>\u003Ccode>[c-&gt;s]: (147) 00000000\n\u003C/code>\u003C/pre>\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-comment\">/// 147 &lt;-&gt;\u003C/span>\nPlayerLoadout {\n    client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    index: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    hide_accessory: \u003Cspan class=\"hljs-type\">u16\u003C/span>,\n},\n\u003C/code>\u003C/pre>\u003Cp>Next, the player sends a whole bunch of type 5 packets. It represents each item the player has on their character. This includes not just inventory items, but also armor, ammo, other loadouts, and more. This gets broadcasted.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-comment\">/// 5 &lt;-&gt;\u003C/span>\nPlayerInventorySlot {\n    client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    slot_id: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n    amount: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n    prefix: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    item_id: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n},\n\u003C/code>\u003C/pre>\u003Cp>Finally, the player sends an empty packet with type 6, which triggers the server to send metadata about the world. After that is received, the client send a type 8 packet which makes the server send back even more world data, which includes some tile data. All the packets until now have been quite simple to implement, but now the client is expecting world data and our program doesn&#39;t hold a world.\u003C/p>\n\u003Ch2>Parsing .wld Files\u003C/h2>\n\u003Cp>In order to get some world data, we should probably parse the .wld file that Terraria store&#39;s world data in. I googled around a bit and it seems that others have already figured out, documented, and written parsers for it in the past. Notably, there is \u003Ca href=\"https://github.com/TEdit/Terraria-Map-Editor\">Terraria Map Editor\u003C/a>, which provides a UI for editing Terraria world files and updating lots of tiles at once with Microsoft Paint-like tools. It&#39;s a neat tool and could be a good reference point to work off. However, after exploring the decompiled code some more, there is a \u003Ccode>WorldFile\u003C/code> class which contains a \u003Ccode>LoadWorld\u003C/code> method. It&#39;s actually not that hard to read, so I&#39;m just going to work off that.\u003C/p>\n\u003Cp>For starters, where does Terraria store \u003Ccode>.wld\u003C/code> file? On Windows, it&#39;s in \u003Ccode>Documents &gt; My Games &gt; Terraria &gt; Worlds\u003C/code>. On macOS, it&#39;s in \u003Ccode>~/Library/Application Support/Terraria/Worlds\u003C/code>. Let&#39;s get the contents of the file and pass it to the reader that was created in \u003Ca href=\"/blog/trust-2\">part 2\u003C/a>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">contents\u003C/span> = fs::\u003Cspan class=\"hljs-title function_ invoke__\">read\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;Courtyard_of_Grasshoppers.wld&quot;\u003C/span>).\u003Cspan class=\"hljs-title function_ invoke__\">unwrap\u003C/span>();\n\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">reader\u003C/span> = Reader::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(contents.\u003Cspan class=\"hljs-title function_ invoke__\">as_slice\u003C/span>());\n\u003C/code>\u003C/pre>\u003Cp>In the decompiled code, the first thing done on the reader is ReadInt32(), and \u003Ccode>WorldFile._versionNumber\u003C/code> is set to that number. Similarly, in our code, we can write the following.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">version\u003C/span> = reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_i32\u003C/span>();\n\u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;File version: {}&quot;\u003C/span>, version);\n\u003C/code>\u003C/pre>\u003Cp>Running this, we get:\u003C/p>\n\u003Cpre>\u003Ccode>File version: 279\n\u003C/code>\u003C/pre>\u003Cp>Nice. It&#39;s the same as the Terraria version from earlier. At this point, there is a branch in the code. Before version 88, we call \u003Ccode>WorldFile.LoadWorld_Version1_Old_BeforeRelease88\u003C/code>. Starting from version 88, \u003Ccode>WorldFile.LoadWorld_Version2\u003C/code> is called. Let&#39;s go ahead and just implement \u003Ccode>WorldFile.LoadWorld_Version2\u003C/code>. We can always support older versions later. Within \u003Ccode>LoadWorld_Version2\u003C/code>, the first function called is \u003Ccode>LoadFileFormatHeader\u003C/code>, which looks like so.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">static\u003C/span> \u003Cspan class=\"hljs-built_in\">bool\u003C/span> \u003Cspan class=\"hljs-title\">LoadFileFormatHeader\u003C/span>(\u003Cspan class=\"hljs-params\">BinaryReader reader, \u003Cspan class=\"hljs-keyword\">out\u003C/span> \u003Cspan class=\"hljs-built_in\">bool\u003C/span>[] importance, \u003Cspan class=\"hljs-keyword\">out\u003C/span> \u003Cspan class=\"hljs-built_in\">int\u003C/span>[] positions\u003C/span>)\u003C/span> {\n    importance = (\u003Cspan class=\"hljs-built_in\">bool\u003C/span>[]) \u003Cspan class=\"hljs-literal\">null\u003C/span>;\n    positions = (\u003Cspan class=\"hljs-built_in\">int\u003C/span>[]) \u003Cspan class=\"hljs-literal\">null\u003C/span>;\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> ((WorldFile._versionNumber = reader.ReadInt32()) &gt;= \u003Cspan class=\"hljs-number\">135\u003C/span>) {\n        \u003Cspan class=\"hljs-keyword\">try\u003C/span> {\n            Main.WorldFileMetadata = FileMetadata.Read(reader, FileType.World);\n        }\n        \u003Cspan class=\"hljs-keyword\">catch\u003C/span> (FormatException ex) {\n            Console.WriteLine(Language.GetTextValue(\u003Cspan class=\"hljs-string\">&quot;Error.UnableToLoadWorld&quot;\u003C/span>));\n            Console.WriteLine((\u003Cspan class=\"hljs-built_in\">object\u003C/span>) ex);\n            \u003Cspan class=\"hljs-keyword\">return\u003C/span> \u003Cspan class=\"hljs-literal\">false\u003C/span>;\n        }\n    }\n    \u003Cspan class=\"hljs-keyword\">else\u003C/span>\n        Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);\n    \u003Cspan class=\"hljs-built_in\">short\u003C/span> length1 = reader.ReadInt16();\n    positions = \u003Cspan class=\"hljs-keyword\">new\u003C/span> \u003Cspan class=\"hljs-built_in\">int\u003C/span>[(\u003Cspan class=\"hljs-built_in\">int\u003C/span>) length1];\n    \u003Cspan class=\"hljs-keyword\">for\u003C/span> (\u003Cspan class=\"hljs-built_in\">int\u003C/span> index = \u003Cspan class=\"hljs-number\">0\u003C/span>; index &lt; (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) length1; ++index)\n        positions[index] = reader.ReadInt32();\n    \u003Cspan class=\"hljs-built_in\">ushort\u003C/span> length2 = reader.ReadUInt16();\n    importance = \u003Cspan class=\"hljs-keyword\">new\u003C/span> \u003Cspan class=\"hljs-built_in\">bool\u003C/span>[(\u003Cspan class=\"hljs-built_in\">int\u003C/span>) length2];\n    \u003Cspan class=\"hljs-built_in\">byte\u003C/span> num1 = \u003Cspan class=\"hljs-number\">0\u003C/span>;\n    \u003Cspan class=\"hljs-built_in\">byte\u003C/span> num2 = \u003Cspan class=\"hljs-number\">128\u003C/span>;\n    \u003Cspan class=\"hljs-keyword\">for\u003C/span> (\u003Cspan class=\"hljs-built_in\">int\u003C/span> index = \u003Cspan class=\"hljs-number\">0\u003C/span>; index &lt; (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) length2; ++index) {\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (num2 == (\u003Cspan class=\"hljs-built_in\">byte\u003C/span>) \u003Cspan class=\"hljs-number\">128\u003C/span>) {\n            num1 = reader.ReadByte();\n            num2 = (\u003Cspan class=\"hljs-built_in\">byte\u003C/span>) \u003Cspan class=\"hljs-number\">1\u003C/span>;\n        }\n        \u003Cspan class=\"hljs-keyword\">else\u003C/span>\n            num2 &lt;&lt;= \u003Cspan class=\"hljs-number\">1\u003C/span>;\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (((\u003Cspan class=\"hljs-built_in\">int\u003C/span>) num1 &amp; (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) num2) == (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) num2)\n            importance[index] = \u003Cspan class=\"hljs-literal\">true\u003C/span>;\n    }\n    \u003Cspan class=\"hljs-keyword\">return\u003C/span> \u003Cspan class=\"hljs-literal\">true\u003C/span>;\n}\n\u003C/code>\u003C/pre>\u003Cp>Ok, so a call to \u003Ccode>FileMetadata.Read\u003C/code> is made. We can navigate to \u003Ccode>FileMetadata\u003C/code> and find that the \u003Ccode>Read\u003C/code> method looks like this.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">private\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">Read\u003C/span>(\u003Cspan class=\"hljs-params\">BinaryReader reader\u003C/span>)\u003C/span> {\n    \u003Cspan class=\"hljs-built_in\">long\u003C/span> num1 = (\u003Cspan class=\"hljs-built_in\">long\u003C/span>) reader.ReadUInt64();\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> ((num1 &amp; \u003Cspan class=\"hljs-number\">72057594037927935L\u003C/span>) != \u003Cspan class=\"hljs-number\">27981915666277746L\u003C/span>)\n        \u003Cspan class=\"hljs-keyword\">throw\u003C/span> \u003Cspan class=\"hljs-keyword\">new\u003C/span> FormatException(\u003Cspan class=\"hljs-string\">&quot;Expected Re-Logic file format.&quot;\u003C/span>);\n    \u003Cspan class=\"hljs-built_in\">byte\u003C/span> num2 = (\u003Cspan class=\"hljs-built_in\">byte\u003C/span>) ((\u003Cspan class=\"hljs-built_in\">ulong\u003C/span>) num1 &gt;&gt; \u003Cspan class=\"hljs-number\">56\u003C/span> &amp; (\u003Cspan class=\"hljs-built_in\">ulong\u003C/span>) \u003Cspan class=\"hljs-built_in\">byte\u003C/span>.MaxValue);\n    FileType fileType = FileType.None;\n    FileType[] values = (FileType[]) Enum.GetValues(\u003Cspan class=\"hljs-keyword\">typeof\u003C/span> (FileType));\n    \u003Cspan class=\"hljs-keyword\">for\u003C/span> (\u003Cspan class=\"hljs-built_in\">int\u003C/span> index = \u003Cspan class=\"hljs-number\">0\u003C/span>; index &lt; values.Length; ++index) {\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (values[index] == (FileType) num2) {\n            fileType = values[index];\n            \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n        }\n    }\n    \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Type = fileType != FileType.None ? fileType : \u003Cspan class=\"hljs-keyword\">throw\u003C/span> \u003Cspan class=\"hljs-keyword\">new\u003C/span> FormatException(\u003Cspan class=\"hljs-string\">&quot;Found invalid file type.&quot;\u003C/span>);\n    \u003Cspan class=\"hljs-keyword\">this\u003C/span>.Revision = reader.ReadUInt32();\n    \u003Cspan class=\"hljs-keyword\">this\u003C/span>.IsFavorite = ((\u003Cspan class=\"hljs-built_in\">long\u003C/span>) reader.ReadUInt64() &amp; \u003Cspan class=\"hljs-number\">1L\u003C/span>) == \u003Cspan class=\"hljs-number\">1L\u003C/span>;\n}\n\u003C/code>\u003C/pre>\u003Cp>If we convert \u003Ccode>72057594037927935\u003C/code> to binary, it&#39;s just 56 \u003Ccode>1\u003C/code>s. If we convert \u003Ccode>27981915666277746\u003C/code> to hexadecimal and use an online hex to ASCII tool, we get \u003Ccode>cigoler\u003C/code>. That&#39;s \u003Ccode>relogic\u003C/code> backwards. \u003Ccode>Re-Logic\u003C/code> is the name of the company that made Terraria. This seems to be a magic number for Re-Logic files. The reason it&#39;s backwards is that we are using little endian encoding. Let&#39;s go ahead and add a check for this magic number.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">magic\u003C/span> = reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_bytes\u003C/span>(\u003Cspan class=\"hljs-number\">7\u003C/span>);\n\u003Cspan class=\"hljs-keyword\">if\u003C/span> magic != \u003Cspan class=\"hljs-string\">&quot;relogic&quot;\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">as_bytes\u003C/span>() {\n    \u003Cspan class=\"hljs-built_in\">panic!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;not a relogic file&quot;\u003C/span>)\n}\n\u003C/code>\u003C/pre>\u003Cp>After this, we can read the \u003Ccode>fileType\u003C/code> as 1 byte.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">file_type\u003C/span> = reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_byte\u003C/span>()?;\n\u003C/code>\u003C/pre>\u003Cp>Running the code, we get this.\u003C/p>\n\u003Cpre>\u003Ccode>File type: 2\n\u003C/code>\u003C/pre>\u003Cp>The code corresponds to this enum.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-built_in\">enum\u003C/span> FileType : \u003Cspan class=\"hljs-built_in\">byte\u003C/span> {\n    None,\n    Map,\n    World,\n    Player,\n}\n\u003C/code>\u003C/pre>\u003Cp>Since we are dealing with a world file, the value 2 makes sense. Next is \u003Ccode>this.Revision = reader.ReadUInt32();\u003C/code> and \u003Ccode>this.IsFavorite = ((long) reader.ReadUInt64() &amp; 1L) == 1L;\u003C/code>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">revision\u003C/span> = reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_u32\u003C/span>();\n\u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;Revision: {}&quot;\u003C/span>, revision);\n\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">favorite\u003C/span> = reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_u64\u003C/span>() &amp; \u003Cspan class=\"hljs-number\">1\u003C/span> == \u003Cspan class=\"hljs-number\">1\u003C/span>;\n\u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;Is favorite: {}&quot;\u003C/span>, favorite);\n\u003C/code>\u003C/pre>\u003Cp>Now, we get this output.\u003C/p>\n\u003Cpre>\u003Ccode>File version: 279\nFile type: 2\nRevision: 3\nIs favorite: false\n\u003C/code>\u003C/pre>\u003Cp>Looks pretty good. Back to the parent function, \u003Ccode>LoadFileFormatHeader\u003C/code>, we read the positions like so.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-built_in\">short\u003C/span> length1 = reader.ReadInt16();\npositions = \u003Cspan class=\"hljs-keyword\">new\u003C/span> \u003Cspan class=\"hljs-built_in\">int\u003C/span>[(\u003Cspan class=\"hljs-built_in\">int\u003C/span>) length1];\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> (\u003Cspan class=\"hljs-built_in\">int\u003C/span> index = \u003Cspan class=\"hljs-number\">0\u003C/span>; index &lt; (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) length1; ++index)\n    positions[index] = reader.ReadInt32();\n\u003C/code>\u003C/pre>\u003Cp>Let&#39;s go ahead and do that in Rust.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">positions\u003C/span> = \u003Cspan class=\"hljs-type\">Vec\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">with_capacity\u003C/span>(reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_i16\u003C/span>() \u003Cspan class=\"hljs-keyword\">as\u003C/span> \u003Cspan class=\"hljs-type\">usize\u003C/span>);\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-variable\">_\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> \u003Cspan class=\"hljs-number\">0\u003C/span>..positions.\u003Cspan class=\"hljs-title function_ invoke__\">capacity\u003C/span>() {\n    positions.\u003Cspan class=\"hljs-title function_ invoke__\">push\u003C/span>(reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_i32\u003C/span>());\n}\n\u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;File positions: {:?}&quot;\u003C/span>, positions);\n\u003C/code>\u003C/pre>\u003Cp>With this in place, we get this in our console:\u003C/p>\n\u003Cpre>\u003Ccode>File positions: [159, 3413, 6618450, 6656473, 6656475, 6656542, 6656546, 6656550, 6656554, 6656576, 6656607]\n\u003C/code>\u003C/pre>\u003Cp>What the Terraria world parser does is that after reading each section of data, it checks that the cursor is at the correct position before proceeding. This turns out to be \u003Cem>really\u003C/em> useful when reading the file myself. It prevents me from accidentally reading loads of garbage without realizing and provides checkpoints for me as I&#39;m writing the parser. If we parsed some block but the cursor doesn&#39;t match, it&#39;s a sign that we did something wrong.\u003C/p>\n\u003Cp>Next up is the code for getting the &quot;importance&quot; of things. At this point it&#39;s not clear what this is for, but becomes apparent when reading the tiles. &quot;important&quot; tiles contain extra data.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">importance\u003C/span> = \u003Cspan class=\"hljs-built_in\">vec!\u003C/span>[\u003Cspan class=\"hljs-literal\">false\u003C/span>; reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_u16\u003C/span>() \u003Cspan class=\"hljs-keyword\">as\u003C/span> \u003Cspan class=\"hljs-type\">usize\u003C/span>];\n\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">byte\u003C/span> = \u003Cspan class=\"hljs-number\">0\u003C/span>;\n\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">mask\u003C/span> = \u003Cspan class=\"hljs-number\">128\u003C/span>;\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-variable\">i\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> &amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> importance {\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> mask == \u003Cspan class=\"hljs-number\">128\u003C/span> {\n        byte = reader.\u003Cspan class=\"hljs-title function_ invoke__\">read_byte\u003C/span>();\n        mask = \u003Cspan class=\"hljs-number\">1\u003C/span>;\n    } \u003Cspan class=\"hljs-keyword\">else\u003C/span> {\n        mask &lt;&lt;= \u003Cspan class=\"hljs-number\">1\u003C/span>;\n    }\n\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> (byte &amp; mask) == mask {\n        *i = \u003Cspan class=\"hljs-literal\">true\u003C/span>;\n    }\n}\n\u003Cspan class=\"hljs-built_in\">println!\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;Importance count: {}&quot;\u003C/span>, importance.\u003Cspan class=\"hljs-title function_ invoke__\">len\u003C/span>());\n\u003C/code>\u003C/pre>\u003Cp>All that this code is doing is reading the individual bits of the reader as booleans. Running this spits out:\u003C/p>\n\u003Cpre>\u003Ccode>Importance count: 693\n\u003C/code>\u003C/pre>\u003Cp>We may also check our \u003Ccode>reader.cur\u003C/code> at this point and see that it is \u003Ccode>159\u003C/code>, which matches the first position in our positions array.\u003C/p>\n\u003Cp>You can imagine how the rest of this goes. It&#39;s basically just writing a bunch of \u003Ca href=\"https://github.com/xDimGG/trust/blob/main/src/world/types.rs\">structs and enums\u003C/a> and lots of calls to the \u003Ca href=\"https://github.com/xDimGG/trust/blob/main/src/world/reader.rs\">reader\u003C/a>. Writing it all out in a blog post would take a very long time and be quite boring. I&#39;ll just tell you the most interesting part.\u003C/p>\n\u003Ch2>Parsing Strings, Revisited\u003C/h2>\n\u003Cp>Once I finished writing the parser, my world file was working just fine. However, I tried downloading someone else&#39;s world file and got an error from \u003Ccode>str::from_utf8\u003C/code>. For some reason, the string wasn&#39;t being parsed correctly. At first, I thought that maybe Terraria files don&#39;t use UTF-8 strings, so I poked around the decompiled code a bit and couldn&#39;t figure out what was wrong. I tried checking the C# documentation for information on how \u003Ca href=\"https://learn.microsoft.com/en-us/uwp/api/windows.storage.streams.datawriter.writestring?view=winrt-22621\">WriteString\u003C/a> encodes the string, however, the only thing the page says is \u003Ccode>Writes a string value to the output stream.\u003C/code>. Very helpful, Microsoft. I walked away from my computer a bit and that&#39;s when it hit me that maybe the strings I&#39;m reading are just too long. Up to this point, I parsed strings by reading the first byte as the length and the rest as the string, which means that I could only support strings of length less than 256. As it turns out, this is not what the C# \u003Ccode>DataWriter\u003C/code> does. In fact, it uses a varying-length integer, similar to UTF-8. What this means is that the first bit represents whether there is still more data about the length.\u003C/p>\n\u003Cp>Suppose we have a string of length 64. Its length will just be encoded as \u003Ccode>01000000\u003C/code>. If our string&#39;s length is 300, which is \u003Ccode>100101100\u003C/code> in binary. The first byte will contain the least seven bits of the number, \u003Ccode>0101100\u003C/code>. The most significant bit will be set to \u003Ccode>1\u003C/code> to signify that there are still more bits to read. The second byte will contain the remaining bits, \u003Ccode>10\u003C/code>, with the most significant bit set to \u003Ccode>0\u003C/code> to signify that there are no more bits. In the end, our \u003Ccode>300\u003C/code> becomes \u003Ccode>10101100 00000010\u003C/code>. Two bytes. Until now, I&#39;ve treated the string length as just 1 byte, which means we actually couldn&#39;t support any string whose length is greater than 127, since the first bit is reserved.\u003C/p>\n\u003Cp>Our updated \u003Ccode>read_string\u003C/code> function looks like this now.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">read_length\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">usize\u003C/span> {\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">length\u003C/span> = \u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">read_byte\u003C/span>() \u003Cspan class=\"hljs-keyword\">as\u003C/span> \u003Cspan class=\"hljs-type\">usize\u003C/span>;\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">shift\u003C/span> = \u003Cspan class=\"hljs-number\">7\u003C/span>;\n    \u003Cspan class=\"hljs-keyword\">while\u003C/span> length &amp; (\u003Cspan class=\"hljs-number\">1\u003C/span> &lt;&lt; shift) != \u003Cspan class=\"hljs-number\">0\u003C/span> {\n        length &amp;= !(\u003Cspan class=\"hljs-number\">1\u003C/span> &lt;&lt; shift);\n        length |= (\u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">read_byte\u003C/span>() \u003Cspan class=\"hljs-keyword\">as\u003C/span> \u003Cspan class=\"hljs-type\">usize\u003C/span>) &lt;&lt; shift;\n        shift += \u003Cspan class=\"hljs-number\">7\u003C/span>;\n    }\n\n    length\n}\n\n\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">read_string\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">String\u003C/span> {\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">length\u003C/span> = \u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">read_length\u003C/span>();\n    std::\u003Cspan class=\"hljs-type\">str\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">from_utf8\u003C/span>(\u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">read_bytes\u003C/span>(length)).\u003Cspan class=\"hljs-title function_ invoke__\">unwrap_or\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;&quot;\u003C/span>).\u003Cspan class=\"hljs-title function_ invoke__\">to_string\u003C/span>()\n}\n\u003C/code>\u003C/pre>\u003Cp>On the write side, it looks like this.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">write_length\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>, \u003Cspan class=\"hljs-keyword\">mut\u003C/span> len: \u003Cspan class=\"hljs-type\">usize\u003C/span>) {\n    \u003Cspan class=\"hljs-keyword\">while\u003C/span> len &gt;= (\u003Cspan class=\"hljs-number\">1\u003C/span> &lt;&lt; \u003Cspan class=\"hljs-number\">7\u003C/span>) {\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">write_byte\u003C/span>((len &amp; \u003Cspan class=\"hljs-number\">0b1111111\u003C/span>) \u003Cspan class=\"hljs-keyword\">as\u003C/span> \u003Cspan class=\"hljs-type\">u8\u003C/span> | (\u003Cspan class=\"hljs-number\">1\u003C/span> &lt;&lt; \u003Cspan class=\"hljs-number\">7\u003C/span>));\n        len &gt;&gt;= \u003Cspan class=\"hljs-number\">7\u003C/span>;\n    }\n\n    \u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">write_byte\u003C/span>(len \u003Cspan class=\"hljs-keyword\">as\u003C/span> \u003Cspan class=\"hljs-type\">u8\u003C/span>)\n}\n\n\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">write_string\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>, string: \u003Cspan class=\"hljs-type\">String\u003C/span>) {\n    \u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">write_length\u003C/span>(string.\u003Cspan class=\"hljs-title function_ invoke__\">len\u003C/span>());\n    \u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">write_bytes\u003C/span>(string.\u003Cspan class=\"hljs-title function_ invoke__\">as_bytes\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">to_vec\u003C/span>())\n}\n\u003C/code>\u003C/pre>\u003Ch2>Up and Running\u003C/h2>\n\u003Cp>Anyway, with that figured out, the World file parser is done! It has an annoyingly large number of fields, but it works. This means that now, we can begin to send world data to the player.\u003C/p>\n\u003Cp>\u003Cimg src=\"/trust-3.png\" alt=\"connecting to trust server\">\u003C/p>\n\u003Cp>It works! For some reason, Re-Logic decided to make world tile packets zlib-compressed, which meant I had to dig into \u003Ca href=\"https://github.com/DinoChiesa/DotNetZip\">DotNetZip\u003C/a> to figure out exactly what parameters were being used. It turns out that the way Terraria uses the library ends up removing the zlib header and trailing checksum. It was quite tricky to figure out, but using the proxy made it easier. As a bonus, I added this to the proxy:\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">disp_data = data[\u003Cspan class=\"hljs-number\">1\u003C/span>:]\n\u003Cspan class=\"hljs-keyword\">if\u003C/span> data[\u003Cspan class=\"hljs-number\">0\u003C/span>] == \u003Cspan class=\"hljs-number\">10\u003C/span>:\n    disp_data = zlib.decompress(disp_data, wbits=-\u003Cspan class=\"hljs-number\">15\u003C/span>)\n\u003Cspan class=\"hljs-built_in\">print\u003C/span>(\u003Cspan class=\"hljs-string\">f&#x27;\u003Cspan class=\"hljs-subst\">{prefix}\u003C/span> (\u003Cspan class=\"hljs-subst\">{data[\u003Cspan class=\"hljs-number\">0\u003C/span>]}\u003C/span>) \u003Cspan class=\"hljs-subst\">{disp_data.\u003Cspan class=\"hljs-built_in\">hex\u003C/span>()}\u003C/span>&#x27;\u003C/span>)\n\u003C/code>\u003C/pre>\u003Cp>which decompresses any packets containing tile data.\u003C/p>\n\u003Ch2>Closing Notes\u003C/h2>\n\u003Cp>So, we have our world and we can move around in it. We can even break blocks, but breaking stuff doesn&#39;t drop anything. In fact, everything we&#39;re doing is only on the client side. In order to support block-breaking and whatnot, we&#39;ll need to mutate the world object. We&#39;ll also have to be able to save the world, which means doing everything we just did in reverse. We&#39;ve come a lot further than what I though would be possible! Everything from here should be smooth sailing. See you again in part 4!\u003C/p>\n","Parsing Terraria's .wld Files (trust pt. 3)",1708364642136,[7,8,9],"binary","rust","trust"],"uses":{"params":["id"]}}]}
