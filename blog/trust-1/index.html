<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../favicon.jpeg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" integrity="sha512-c42qTSw/wPZ3/5LBzD+Bw5f7bSF2oxou6wEb+I/lqeaKV5FDIfMvvRp772y4jcJLKuGUOpbJMdg/BTl50fJYAw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
		
		<link href="../../_app/immutable/assets/0.1aaef01e.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/4.2a853ecf.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.08ee98e4.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/scheduler.e108d1fd.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/singletons.0f661fa2.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.515171e9.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index.48054bed.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.5ae7a652.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/4.765ce7f2.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/each.e59479a4.js"><title>Exploring Terraria's Server Protocol (trust pt. 1)</title><!-- HEAD_svelte-1n6ckfq_START --><link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet"><!-- HEAD_svelte-1n6ckfq_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">   <div class="min-h-screen w-full dark:bg-slate-900 px-3 py-8"><div class="prose prose-img:max-h-[80vh] prose-img:mx-auto prose-gray dark:prose-invert lg:max-w-[1000px] mx-auto"><div class="flex justify-between"><h1 class="mb-0">Exploring Terraria's Server Protocol (trust pt. 1)</h1> <div class="block text-xs text-right text-opacity-50 shrink-0 ml-2"><a href="/blog/" class="xt-slate-500 dark:text-white block no-underline hover:underline" data-svelte-h="svelte-6j3ym0">other posts</a> <span class="text-slate-500 dark:text-slate-400">2/9/2024</span></div></div> <a href="/blog/?tag=python" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">python</a><span class="text-slate-500 dark:text-slate-400">, </span><a href="/blog/?tag=reverse-engineering" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">reverse-engineering</a><span class="text-slate-500 dark:text-slate-400">, </span><a href="/blog/?tag=tcp" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">tcp</a><span class="text-slate-500 dark:text-slate-400">, </span><a href="/blog/?tag=trust" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">trust</a><span class="text-slate-500 dark:text-slate-400"></span> <!-- HTML_TAG_START --><p>Greetings, traveler. Welcome to my series on attempting to implement a game server for <a href="https://store.steampowered.com/app/105600/Terraria/">Terraria</a>, my personal favorite game.</p>
<h2>Motivation</h2>
<p>I played Terraria on my X-Box 360 in 2013, on my PC in 2015, and on my phone in 2016. The numbers might not be perfectly accurate, but it&#39;s safe to say that I really like the game. I purchased it three times, after all. Since 2018, I&#39;ve gradually become more interested in servers and reverse engineering.</p>
<p><a href="https://github.com/Pryaxis/TShock">TShock</a> is a dedicated Terraria server that uses <a href="https://github.com/SignatureBeef/Open-Terraria-API">Open Terraria API</a>, which rewrites and hooks into the original Terraria server binary to expose the internal Terraria C# API. It works well and is not a Terraria server written from scratch, but rather an extension to the original server.</p>
<p>After a bit of searching, it appears that no one has actually fully written a Terraria server from scratch. Perhaps that&#39;s for a good reason and I&#39;m doing something stupid here. I wouldn&#39;t be surprised if someone has successfully done this before.</p>
<p>I&#39;m still learning Rust, and I&#39;m quite far from basic competency, but I&#39;d like to reverse engineer the server protocol and create a <em>ðŸš€âš¡blazing fast ðŸš€âš¡</em> vanilla game server in Rust that I can connect to with the native Terraria client.</p>
<p>Basically, I&#39;m doing this because I like Terraria. I like reverse engineering things. And I want to get better at Rust. I&#39;m not sure how I&#39;ll manage discussing implementation details, since most of it is pretty boring. I will try my best to make the content interesting. If you want to see the code, the repository will always be <a href="https://github.com/xDimGG/trust">here</a>.</p>
<h2>Choosing Our Method</h2>
<p>We have two main ways that we can approach this.</p>
<ol>
<li>We can decompile the server executable that is shipped with the Steam game and figure out how it does everything.</li>
<li>We can create a man-in-the-middle proxy server to capture the raw data being sent between client and server.</li>
</ol>
<p>Before jumping straight to a disassembler, we should check out what language Terraria is written in. If we google &quot;what is terraria written in&quot;, we can see that it&#39;s written in C#. C# can be decompiled by a variety of software, but my personal favorite is <a href="https://www.jetbrains.com/decompiler/">dotPeek</a>, a free .NET decompiler and assembly browser.</p>
<h2>Decompiling Executables</h2>
<p>If we navigate to Steam, right click on Terraria, go to Properties, go to Local Files, and click Browse, Terraria&#39;s folder will open up. There exist two files of interest: <code>Terraria.exe</code> and <code>TerrariaServer.exe</code>. Let&#39;s go ahead and open up the latter in dotPeek. Expanding the Terraria element, we see a plethora of classes and namespaces. I prefer working in VS Code so I exported the project and opened up the folder in there.</p>
<p><img src="/trust-1-1.png" alt="vs code screenshot"></p>
<p>At least they&#39;re human readable. In here, there are two files that concern us. <code>MessageBuffer.cs</code> and <code>NetMessage.cs</code>. <code>NetMessage.cs</code> has a <code>SendData</code> method which takes some parameters and produces a binary message to be sent over the wire. <code>MessageBuffer.cs</code> has a <code>GetData</code> which uses its internal buffer to parse a binary message.</p>
<p>Hold on. How did I pluck out these two methods out of the mess that is 100+ C# files? A lot of poking around is how. I skimmed through a few files and noticed that a lot of them were making calls to <code>NetMessage.SendData</code> whenever some the client performs an action. After opening up the file, I found a huge switch statement, so I figured that this method probably had something to do with encoding. I found <code>MessageBuffer.GetData</code> through more poking around. The name seemed important and it also had a huge switch statement. Anyway, here&#39;s a snippet of what <code>NetMessage.SendData</code> looks like:</p>
<pre><code class="hljs language-cs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendData</span>(<span class="hljs-params">
    <span class="hljs-built_in">int</span> msgType,
    <span class="hljs-built_in">int</span> remoteClient = <span class="hljs-number">-1</span>,
    <span class="hljs-built_in">int</span> ignoreClient = <span class="hljs-number">-1</span>,
    NetworkText text = <span class="hljs-literal">null</span>,
    <span class="hljs-built_in">int</span> number = <span class="hljs-number">0</span>,
    <span class="hljs-comment">/* 3 more floats and 3 more ints */</span>
    </span>)</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-comment">// index to our own writer</span>
        <span class="hljs-built_in">int</span> index1 = <span class="hljs-number">256</span>;
        <span class="hljs-comment">// if we are server and are sending to some particular client, use their writer index</span>
        <span class="hljs-keyword">if</span> (Main.netMode == <span class="hljs-number">2</span> &amp;&amp; remoteClient &gt;= <span class="hljs-number">0</span>)
            index1 = remoteClient;

        <span class="hljs-keyword">lock</span> (NetMessage.buffer[index1]) {
            BinaryWriter writer = NetMessage.buffer[index1].writer; <span class="hljs-comment">// get the writer for this </span>
            <span class="hljs-keyword">if</span> (writer == <span class="hljs-literal">null</span>) {
                NetMessage.buffer[index1].ResetWriter();
                writer = NetMessage.buffer[index1].writer;
            }
            <span class="hljs-built_in">long</span> position1 = writer.BaseStream.Position; <span class="hljs-comment">// get our current position</span>
            writer.BaseStream.Position += <span class="hljs-number">2L</span>; <span class="hljs-comment">// skip the first two bytes</span>
            writer.Write((<span class="hljs-built_in">byte</span>) msgType); <span class="hljs-comment">// write a byte containing the message type</span>
            <span class="hljs-keyword">switch</span> (msgType) { <span class="hljs-comment">// perform the rest of the encoding based on the message type</span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                    writer.Write(<span class="hljs-string">&quot;Terraria&quot;</span> + (<span class="hljs-built_in">object</span>) <span class="hljs-number">279</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                    <span class="hljs-comment">// ... all the way up to 147 as of Terraria 1.4.4.9</span>
            }
            <span class="hljs-built_in">int</span> position2 = (<span class="hljs-built_in">int</span>) writer.BaseStream.Position; <span class="hljs-comment">// get the current length of our data</span>
            writer.BaseStream.Position = position1; <span class="hljs-comment">// set our buffer position to the start</span>
            writer.Write((<span class="hljs-built_in">ushort</span>) position2); <span class="hljs-comment">// write our length as the first two bytes</span>
            writer.BaseStream.Position = (<span class="hljs-built_in">long</span>) position2; <span class="hljs-comment">// move our cursor back to the end</span>
            <span class="hljs-comment">// ...</span>
        }
    }
</code></pre><p>If we go back to <code>NetMessage</code>, we can find the following line defining <code>buffer</code>.</p>
<pre><code class="hljs language-cs"><span class="hljs-keyword">public</span> BinaryWriter writer;
</code></pre><p><code>BinaryWriter</code> is just a standard .NET class whose documentation can be found <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write">here</a>. If we read the documentation, we see that numbers are written using <a href="https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/">little endian byte ordering</a>. That&#39;s enough C# for now. Let&#39;s create a man-in-the-middle proxy server.</p>
<h2>Making an MITM Proxy to Decode Messages</h2>
<p>For those who are not familiar, man-in-the-middle means we will have a server that sits between the client and the server and handles communication. Proxy means we&#39;re just passing the information down. What we&#39;ll have to do to get this working is start up a legitimate Terraria server on some port, say 7778, and start our proxy server on some other port, say 7777, and have the Terraria client conect to our proxy on port 7777. The proxy will receive data from the client and send it to the server and vice versa.</p>
<p>While the packet is in transit, we can log it to see what kind of interesting packets are being sent. This gives us a high-level view of the protocol and will make it easier to figure out what to look for in the C# files. <em>Spoiler: we may also modify the packet while it is in transit to produce some interesting behavior on the client and server.</em></p>
<p>For this part, I&#39;ll just be using Python. It&#39;s a good language for prototyping this kinda of thing. First off, let&#39;s define our ports and hosts. Everything we&#39;re doing will be on localhost so I&#39;m just using one constant to represent both.</p>
<pre><code class="hljs language-py">HOST = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span> <span class="hljs-comment"># localhost</span>
PORT = <span class="hljs-number">7777</span>  <span class="hljs-comment"># Port to listen on (non-privileged ports are &gt; 1023)</span>
REAL_PORT = <span class="hljs-number">7778</span> <span class="hljs-comment"># Port on which the actual Terraria server is already running</span>
</code></pre><p>Now, let&#39;s create a TCP server that can handle multiple clients. Handling multiple clients won&#39;t be necessary for a while, but it&#39;s nice to have.</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread

<span class="hljs-keyword">def</span> <span class="hljs-title function_">start_proxy</span>(<span class="hljs-params">client</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">with</span> client:
            <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> server:
                server.connect((HOST, REAL_PORT))

                threads = [ <span class="hljs-comment"># we will define copy() in a moment</span>
                    Thread(target=copy, args=(client, server, <span class="hljs-string">&#x27;[c-&gt;s]:&#x27;</span>)),
                    Thread(target=copy, args=(server, client, <span class="hljs-string">&#x27;[s-&gt;c]:&#x27;</span>)),
                ]
                <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads: t.start()
                <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads: t.join()

        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Client has disconnected or true server stopped&#x27;</span>)
    <span class="hljs-keyword">except</span>:
        <span class="hljs-keyword">pass</span>

<span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> s:
    s.bind((HOST, PORT))
    s.listen()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Proxy started on port <span class="hljs-subst">{PORT}</span>&#x27;</span>)

    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        conn, addr = s.accept()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Client <span class="hljs-subst">{addr}</span> has connected&#x27;</span>)
        t = Thread(target=start_proxy, args=(conn, ))
        t.start()
</code></pre><p>What is the code doing? Well, we&#39;re creating a <code>socket.socket</code> as <code>s</code>. We pass in <code>socket.AF_INET</code> since we are using IPv4 and <code>socket.SOCK_STREAM</code> since we are using TCP. Based on what I know about game servers, it is likely that Terraria uses TCP. We could make sure of it by using Wireshark, but this is most likely the case.</p>
<p>Next, we are binding to 127.0.0.1:7777 and calling listen since we are a server. Then we enter an loop where we try to accept incoming connections. <code>accept</code> is blocking so nothing happens until someone connects. When someone has connected, we may start a thread for them and pass the connection as an argument. We don&#39;t join this thread since we want to be ready for the next client.</p>
<p>The <code>start_proxy</code> function takes a client connection and creates the &quot;real&quot; connection with the Terraria server. Our process is now acting as a client, and we can forward messages to and from the server by using the copy() function which we are about to define. <em>Note: <code>try: ... except: pass</code> is used so that our process doesn&#39;t crash when someone disconnects or the real server shuts down.</em></p>
<pre><code class="hljs language-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">src, dst, prefix</span>):
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-comment"># try getting the bytes representing the length of the packet</span>
            data_size = src.recv(<span class="hljs-number">2</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data_size:
                <span class="hljs-keyword">break</span>

            <span class="hljs-comment"># parse the bytes to an int using LE ordering</span>
            <span class="hljs-comment"># minus 2 since we&#x27;re excluding the first two bytes we read</span>
            size = <span class="hljs-built_in">int</span>.from_bytes(data_size, <span class="hljs-string">&#x27;little&#x27;</span>) - <span class="hljs-number">2</span>
            <span class="hljs-comment"># try getting the rest of the packet</span>
            data = src.recv(size)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:
                <span class="hljs-keyword">break</span>

            <span class="hljs-comment"># data[0] is our message code</span>
            <span class="hljs-comment"># data[1:] is the encoded message</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">{prefix}</span> (<span class="hljs-subst">{data[<span class="hljs-number">0</span>]}</span>) <span class="hljs-subst">{data[<span class="hljs-number">1</span>:].<span class="hljs-built_in">hex</span>()}</span>&#x27;</span>)
            <span class="hljs-comment"># forward the message to the receiver</span>
            dst.sendall(data_size + data)
    <span class="hljs-keyword">except</span>:
        <span class="hljs-keyword">pass</span>
</code></pre><p>With that in place and running, we can now start a real Terraria server on port 7778 and connect with the Terraria client to port 7777. The game looks and plays as it normally does, but in the background we are now logging all of the packets being transmitted. Here&#39;s what the console looks like:</p>
<pre><code>Proxy started on port 7777
Client (&#x27;127.0.0.1&#x27;, 51183) has connected
[c-&gt;s]: (1) 0b5465727261726961323739
[s-&gt;c]: (37) 
[c-&gt;s]: (38) 0870617373776f7264
[s-&gt;c]: (3) 0100
[c-&gt;s]: (4) 0103890364696d00000000fbfbfaf57f5e421c32e5cfd6eadbf6b2bbb8e0abfd001000
[c-&gt;s]: (68) 2430336439363837622d623631372d346435642d396161322d623739316461356332346233
[c-&gt;s]: (16) 0190019001
[c-&gt;s]: (42) 0114001400
...
</code></pre><p>So, the client starts by send a type 1 message with some data after it. Let&#39;s recall the C# we looked at earlier.</p>
<pre><code class="hljs language-cs"><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    writer.Write(<span class="hljs-string">&quot;Terraria&quot;</span> + (<span class="hljs-built_in">object</span>) <span class="hljs-number">279</span>);
    <span class="hljs-keyword">break</span>;
</code></pre><p>It seems that the message contains Terraria279. I&#39;m guessing <code>0b</code> is the length of the string and <code>5465727261726961323739</code> is the string (after being hex encoded). <code>Terraria279</code> is 11 digits long and 11 in hex is B so that checks out. Using <a href="https://www.rapidtables.com/convert/number/hex-to-ascii.html">this site</a>, you can convert the hex string to ASCII and see the result. Go on, give it a shot.</p>
<p>Okay, so the client first tells the server what version they&#39;re running and if it&#39;s compatible, the server responds with a type 37 message. Let&#39;s look at the logic for when the server reads a type 1 message from the client. <em>Remember, message decoding is done by <code>MessageBuffer.GetData</code>.</em></p>
<pre><code class="hljs language-cs"><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
    <span class="hljs-comment">// If we are not a server, ignore this packet.</span>
    <span class="hljs-keyword">if</span> (Main.netMode != <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;
    <span class="hljs-comment">// Check if this player is IP banned</span>
    <span class="hljs-keyword">if</span> (Main.dedServ &amp;&amp; Netplay.IsBanned(Netplay.Clients[<span class="hljs-keyword">this</span>.whoAmI].Socket.GetRemoteAddress())) {
        <span class="hljs-comment">// Send the player a localization key informing them they are banned</span>
        NetMessage.TrySendData(<span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>.whoAmI, text: Lang.mp[<span class="hljs-number">3</span>].ToNetworkText());
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">// If this client is not on the state 0</span>
    <span class="hljs-keyword">if</span> (Netplay.Clients[<span class="hljs-keyword">this</span>.whoAmI].State != <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reader.ReadString() == <span class="hljs-string">&quot;Terraria&quot;</span> + (<span class="hljs-built_in">object</span>) <span class="hljs-number">279</span>) {
        <span class="hljs-comment">// If there is no server password, send the client packet 3 and set their state to 1</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.IsNullOrEmpty(Netplay.ServerPassword)) {
            Netplay.Clients[<span class="hljs-keyword">this</span>.whoAmI].State = <span class="hljs-number">1</span>;
            NetMessage.TrySendData(<span class="hljs-number">3</span>, <span class="hljs-keyword">this</span>.whoAmI);
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-comment">// If there is a password, set the client&#x27;s state to -1 and send them packet 37</span>
        Netplay.Clients[<span class="hljs-keyword">this</span>.whoAmI].State = <span class="hljs-number">-1</span>;
        NetMessage.TrySendData(<span class="hljs-number">37</span>, <span class="hljs-keyword">this</span>.whoAmI);
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">// If the version doesn&#x27;t match, send them this string</span>
    NetMessage.TrySendData(<span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>.whoAmI, text: Lang.mp[<span class="hljs-number">4</span>].ToNetworkText());
    <span class="hljs-keyword">break</span>;
</code></pre><p>Something I haven&#39;t mentioned quite yet is that the Terraria server and client code is merged into one. The server is the same as the client but with <code>Main.dedServer = true</code>. This differentiation is made throughout the network code by checking if <code>Main.netMode</code> is 2. As far as I can tell 1 means client and 2 means server. There is also sometimes 0, which I believe represents a client that is not actively in a world? I&#39;m not exactly sure and it doesn&#39;t seem to matter to us.</p>
<p>I have set a password for the server, so it should be sending a type 37 packet, which it does. The client responds with 38 which presumably contains the password I inputted in Terraria. See if you can figure out what the string contains in the line <code>[c-&gt;s]: (38) 0870617373776f7264</code>.</p>
<p>I think that&#39;s enough of explaining the protocol for now. There are so many different packets being sent, so I&#39;ll leave the explanation there for now.</p>
<h2>Exploiting the Server</h2>
<p>Earlier, I did hint at changing the packet data while in transit. Well, an interesting one to change is the packet for putting an item in a chest. When the client puts an item in a chest, the following packet is received and handled by the server like so.</p>
<pre><code class="hljs language-cs"><span class="hljs-keyword">case</span> <span class="hljs-number">32</span>:
    <span class="hljs-built_in">int</span> index28 = (<span class="hljs-built_in">int</span>) <span class="hljs-keyword">this</span>.reader.ReadInt16();
    <span class="hljs-built_in">int</span> index29 = (<span class="hljs-built_in">int</span>) <span class="hljs-keyword">this</span>.reader.ReadByte();
    <span class="hljs-built_in">int</span> num42 = (<span class="hljs-built_in">int</span>) <span class="hljs-keyword">this</span>.reader.ReadInt16();
    <span class="hljs-built_in">int</span> prefixWeWant2 = (<span class="hljs-built_in">int</span>) <span class="hljs-keyword">this</span>.reader.ReadByte();
    <span class="hljs-built_in">int</span> type6 = (<span class="hljs-built_in">int</span>) <span class="hljs-keyword">this</span>.reader.ReadInt16();
    <span class="hljs-comment">// ... some sanity checks ...</span>
    Main.chest[index28].item[index29].netDefaults(type6);
    Main.chest[index28].item[index29].Prefix(prefixWeWant2);
    Main.chest[index28].item[index29].stack = num42;
    Recipe.FindRecipes(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">break</span>;
</code></pre><p>Maybe we can change the value of <code>stack</code> while in transit to put more items in the chest? Let&#39;s try it out by writing the following in our Python method from earlier.</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-number">32</span>:
    <span class="hljs-comment"># make data a bytearray so we can mutate it</span>
    data = <span class="hljs-built_in">bytearray</span>(data)
    <span class="hljs-comment"># note: message type byte + i16 + byte = 4 bytes</span>
    <span class="hljs-comment"># we want to overwrite bytes 4 and 5 with the new stack number</span>
    data[<span class="hljs-number">4</span>:<span class="hljs-number">6</span>] = <span class="hljs-built_in">int</span>(<span class="hljs-number">999</span>).to_bytes(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;little&#x27;</span>)
</code></pre><p>And that&#39;s it! Let&#39;s see what happens in-game.</p>
<p><video src="/trust-1-2.mp4" type="video/mp4" controls></video></p>
<p>Exiting and re-entering a chest gives us 999 of what we put in, even if the item isn&#39;t stackable. In general, the Terraria server seems to not do any anti-cheat prevention, so modifying packets works pretty often. The Terraria server does have a lot of anti-spam code to prevent clients from rapidly sending messages, projectiles, attack commands, placing blocks, and so on. I assume this is mainly to prevent other clients from crashing.</p>
<h2>Recap</h2>
<ul>
<li>Terraria uses plain old TCP with no encryption.</li>
<li>Terraria is written in C#, for which there are many high-quality disassembly tools available.<ul>
<li>dotPeek is pretty good.</li>
</ul>
</li>
<li>A Terraria server can&#39;t have more than 255 players since each player is represented by a byte identifier.</li>
<li><code>Terraria.exe</code> and <code>TerrariaServer.exe</code> are very similar. One is just <code>Main.dedServer = true;</code> and the other is not.</li>
<li>Cheating is fine but crashing other clients is not.</li>
</ul>
<h2>Conclusion</h2>
<p>We have a lot of work cut out for us. We have to handle <a href="https://fileformat.fandom.com/wiki/WLD">world (.wld) files</a>. We may even have to implement world generation! Or copy it if we&#39;re lazy. We may have to parse user files. We have a lot of different packet types to implement. Maybe even fluid simulation. Did you think this would be easy?? Anyway, thanks for reading. See you in <a href="/blog/trust-2">part 2</a>.</p>
<!-- HTML_TAG_END --></div></div> 
			
			<script>
				{
					__sveltekit_1oj7eta = {
						base: new URL("../..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [null,{"type":"data","data":{id:"trust-1",content:"{\n\t\"title\": \"Exploring Terraria's Server Protocol (trust pt. 1)\",\n\t\"date\": 1707490172482,\n\t\"tags\": [\"trust\", \"python\", \"tcp\", \"reverse-engineering\"]\n}\n---\n\nGreetings, traveler. Welcome to my series on attempting to implement a game server for [Terraria](https://store.steampowered.com/app/105600/Terraria/), my personal favorite game.\n\n## Motivation\n\nI played Terraria on my X-Box 360 in 2013, on my PC in 2015, and on my phone in 2016. The numbers might not be perfectly accurate, but it's safe to say that I really like the game. I purchased it three times, after all. Since 2018, I've gradually become more interested in servers and reverse engineering.\n\n[TShock](https://github.com/Pryaxis/TShock) is a dedicated Terraria server that uses [Open Terraria API](https://github.com/SignatureBeef/Open-Terraria-API), which rewrites and hooks into the original Terraria server binary to expose the internal Terraria C# API. It works well and is not a Terraria server written from scratch, but rather an extension to the original server.\n\nAfter a bit of searching, it appears that no one has actually fully written a Terraria server from scratch. Perhaps that's for a good reason and I'm doing something stupid here. I wouldn't be surprised if someone has successfully done this before.\n\nI'm still learning Rust, and I'm quite far from basic competency, but I'd like to reverse engineer the server protocol and create a _ðŸš€âš¡blazing fast ðŸš€âš¡_ vanilla game server in Rust that I can connect to with the native Terraria client.\n\nBasically, I'm doing this because I like Terraria. I like reverse engineering things. And I want to get better at Rust. I'm not sure how I'll manage discussing implementation details, since most of it is pretty boring. I will try my best to make the content interesting. If you want to see the code, the repository will always be [here](https://github.com/xDimGG/trust).\n\n## Choosing Our Method\n\nWe have two main ways that we can approach this.\n\n1. We can decompile the server executable that is shipped with the Steam game and figure out how it does everything.\n2. We can create a man-in-the-middle proxy server to capture the raw data being sent between client and server.\n\nBefore jumping straight to a disassembler, we should check out what language Terraria is written in. If we google \"what is terraria written in\", we can see that it's written in C#. C# can be decompiled by a variety of software, but my personal favorite is [dotPeek](https://www.jetbrains.com/decompiler/), a free .NET decompiler and assembly browser.\n\n## Decompiling Executables\n\nIf we navigate to Steam, right click on Terraria, go to Properties, go to Local Files, and click Browse, Terraria's folder will open up. There exist two files of interest: `Terraria.exe` and `TerrariaServer.exe`. Let's go ahead and open up the latter in dotPeek. Expanding the Terraria element, we see a plethora of classes and namespaces. I prefer working in VS Code so I exported the project and opened up the folder in there.\n\n![vs code screenshot](/trust-1-1.png)\n\nAt least they're human readable. In here, there are two files that concern us. `MessageBuffer.cs` and `NetMessage.cs`. `NetMessage.cs` has a `SendData` method which takes some parameters and produces a binary message to be sent over the wire. `MessageBuffer.cs` has a `GetData` which uses its internal buffer to parse a binary message.\n\nHold on. How did I pluck out these two methods out of the mess that is 100+ C# files? A lot of poking around is how. I skimmed through a few files and noticed that a lot of them were making calls to `NetMessage.SendData` whenever some the client performs an action. After opening up the file, I found a huge switch statement, so I figured that this method probably had something to do with encoding. I found `MessageBuffer.GetData` through more poking around. The name seemed important and it also had a huge switch statement. Anyway, here's a snippet of what `NetMessage.SendData` looks like:\n\n```cs\npublic static void SendData(\n\tint msgType,\n\tint remoteClient = -1,\n\tint ignoreClient = -1,\n\tNetworkText text = null,\n\tint number = 0,\n\t/* 3 more floats and 3 more ints */\n\t) {\n\t\t// ...\n\t\t// index to our own writer\n\t\tint index1 = 256;\n\t\t// if we are server and are sending to some particular client, use their writer index\n\t\tif (Main.netMode == 2 && remoteClient >= 0)\n\t\t\tindex1 = remoteClient;\n\n\t\tlock (NetMessage.buffer[index1]) {\n\t\t\tBinaryWriter writer = NetMessage.buffer[index1].writer; // get the writer for this \n\t\t\tif (writer == null) {\n\t\t\t\tNetMessage.buffer[index1].ResetWriter();\n\t\t\t\twriter = NetMessage.buffer[index1].writer;\n\t\t\t}\n\t\t\tlong position1 = writer.BaseStream.Position; // get our current position\n\t\t\twriter.BaseStream.Position += 2L; // skip the first two bytes\n\t\t\twriter.Write((byte) msgType); // write a byte containing the message type\n\t\t\tswitch (msgType) { // perform the rest of the encoding based on the message type\n\t\t\t\tcase 1:\n\t\t\t\t\twriter.Write(\"Terraria\" + (object) 279);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t// ... all the way up to 147 as of Terraria 1.4.4.9\n\t\t\t}\n\t\t\tint position2 = (int) writer.BaseStream.Position; // get the current length of our data\n\t\t\twriter.BaseStream.Position = position1; // set our buffer position to the start\n\t\t\twriter.Write((ushort) position2); // write our length as the first two bytes\n\t\t\twriter.BaseStream.Position = (long) position2; // move our cursor back to the end\n\t\t\t// ...\n\t\t}\n\t}\n```\n\nIf we go back to `NetMessage`, we can find the following line defining `buffer`.\n\n```cs\npublic BinaryWriter writer;\n```\n\n`BinaryWriter` is just a standard .NET class whose documentation can be found [here](https://learn.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write). If we read the documentation, we see that numbers are written using [little endian byte ordering](https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/). That's enough C# for now. Let's create a man-in-the-middle proxy server.\n\n## Making an MITM Proxy to Decode Messages\n\nFor those who are not familiar, man-in-the-middle means we will have a server that sits between the client and the server and handles communication. Proxy means we're just passing the information down. What we'll have to do to get this working is start up a legitimate Terraria server on some port, say 7778, and start our proxy server on some other port, say 7777, and have the Terraria client conect to our proxy on port 7777. The proxy will receive data from the client and send it to the server and vice versa.\n\nWhile the packet is in transit, we can log it to see what kind of interesting packets are being sent. This gives us a high-level view of the protocol and will make it easier to figure out what to look for in the C# files. *Spoiler: we may also modify the packet while it is in transit to produce some interesting behavior on the client and server.*\n\nFor this part, I'll just be using Python. It's a good language for prototyping this kinda of thing. First off, let's define our ports and hosts. Everything we're doing will be on localhost so I'm just using one constant to represent both.\n\n```py\nHOST = '127.0.0.1' # localhost\nPORT = 7777  # Port to listen on (non-privileged ports are > 1023)\nREAL_PORT = 7778 # Port on which the actual Terraria server is already running\n```\n\nNow, let's create a TCP server that can handle multiple clients. Handling multiple clients won't be necessary for a while, but it's nice to have.\n\n```py\nimport socket\nfrom threading import Thread\n\ndef start_proxy(client):\n\ttry:\n\t\twith client:\n\t\t\twith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:\n\t\t\t\tserver.connect((HOST, REAL_PORT))\n\n\t\t\t\tthreads = [ # we will define copy() in a moment\n\t\t\t\t\tThread(target=copy, args=(client, server, '[c->s]:')),\n\t\t\t\t\tThread(target=copy, args=(server, client, '[s->c]:')),\n\t\t\t\t]\n\t\t\t\tfor t in threads: t.start()\n\t\t\t\tfor t in threads: t.join()\n\n\t\tprint(f'Client has disconnected or true server stopped')\n\texcept:\n\t\tpass\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n\ts.bind((HOST, PORT))\n\ts.listen()\n\tprint(f'Proxy started on port {PORT}')\n\n\twhile True:\n\t\tconn, addr = s.accept()\n\t\tprint(f'Client {addr} has connected')\n\t\tt = Thread(target=start_proxy, args=(conn, ))\n\t\tt.start()\n```\n\nWhat is the code doing? Well, we're creating a `socket.socket` as `s`. We pass in `socket.AF_INET` since we are using IPv4 and `socket.SOCK_STREAM` since we are using TCP. Based on what I know about game servers, it is likely that Terraria uses TCP. We could make sure of it by using Wireshark, but this is most likely the case.\n\nNext, we are binding to 127.0.0.1:7777 and calling listen since we are a server. Then we enter an loop where we try to accept incoming connections. `accept` is blocking so nothing happens until someone connects. When someone has connected, we may start a thread for them and pass the connection as an argument. We don't join this thread since we want to be ready for the next client.\n\nThe `start_proxy` function takes a client connection and creates the \"real\" connection with the Terraria server. Our process is now acting as a client, and we can forward messages to and from the server by using the copy() function which we are about to define. *Note: `try: ... except: pass` is used so that our process doesn't crash when someone disconnects or the real server shuts down.*\n\n```py\ndef copy(src, dst, prefix):\n\ttry:\n\t\twhile True:\n\t\t\t# try getting the bytes representing the length of the packet\n\t\t\tdata_size = src.recv(2)\n\t\t\tif not data_size:\n\t\t\t\tbreak\n\n\t\t\t# parse the bytes to an int using LE ordering\n\t\t\t# minus 2 since we're excluding the first two bytes we read\n\t\t\tsize = int.from_bytes(data_size, 'little') - 2\n\t\t\t# try getting the rest of the packet\n\t\t\tdata = src.recv(size)\n\t\t\tif not data:\n\t\t\t\tbreak\n\n\t\t\t# data[0] is our message code\n\t\t\t# data[1:] is the encoded message\n\t\t\tprint(f'{prefix} ({data[0]}) {data[1:].hex()}')\n\t\t\t# forward the message to the receiver\n\t\t\tdst.sendall(data_size + data)\n\texcept:\n\t\tpass\n```\n\nWith that in place and running, we can now start a real Terraria server on port 7778 and connect with the Terraria client to port 7777. The game looks and plays as it normally does, but in the background we are now logging all of the packets being transmitted. Here's what the console looks like:\n\n```\nProxy started on port 7777\nClient ('127.0.0.1', 51183) has connected\n[c->s]: (1) 0b5465727261726961323739\n[s->c]: (37) \n[c->s]: (38) 0870617373776f7264\n[s->c]: (3) 0100\n[c->s]: (4) 0103890364696d00000000fbfbfaf57f5e421c32e5cfd6eadbf6b2bbb8e0abfd001000\n[c->s]: (68) 2430336439363837622d623631372d346435642d396161322d623739316461356332346233\n[c->s]: (16) 0190019001\n[c->s]: (42) 0114001400\n...\n```\n\nSo, the client starts by send a type 1 message with some data after it. Let's recall the C# we looked at earlier.\n\n```cs\ncase 1:\n\twriter.Write(\"Terraria\" + (object) 279);\n\tbreak;\n```\n\nIt seems that the message contains Terraria279. I'm guessing `0b` is the length of the string and `5465727261726961323739` is the string (after being hex encoded). `Terraria279` is 11 digits long and 11 in hex is B so that checks out. Using [this site](https://www.rapidtables.com/convert/number/hex-to-ascii.html), you can convert the hex string to ASCII and see the result. Go on, give it a shot.\n\nOkay, so the client first tells the server what version they're running and if it's compatible, the server responds with a type 37 message. Let's look at the logic for when the server reads a type 1 message from the client. *Remember, message decoding is done by `MessageBuffer.GetData`.*\n\n```cs\ncase 1:\n\t// If we are not a server, ignore this packet.\n\tif (Main.netMode != 2) break;\n\t// Check if this player is IP banned\n\tif (Main.dedServ && Netplay.IsBanned(Netplay.Clients[this.whoAmI].Socket.GetRemoteAddress())) {\n\t\t// Send the player a localization key informing them they are banned\n\t\tNetMessage.TrySendData(2, this.whoAmI, text: Lang.mp[3].ToNetworkText());\n\t\tbreak;\n\t}\n\t// If this client is not on the state 0\n\tif (Netplay.Clients[this.whoAmI].State != 0) break;\n\tif (this.reader.ReadString() == \"Terraria\" + (object) 279) {\n\t\t// If there is no server password, send the client packet 3 and set their state to 1\n\t\tif (string.IsNullOrEmpty(Netplay.ServerPassword)) {\n\t\t\tNetplay.Clients[this.whoAmI].State = 1;\n\t\t\tNetMessage.TrySendData(3, this.whoAmI);\n\t\t\tbreak;\n\t\t}\n\t\t// If there is a password, set the client's state to -1 and send them packet 37\n\t\tNetplay.Clients[this.whoAmI].State = -1;\n\t\tNetMessage.TrySendData(37, this.whoAmI);\n\t\tbreak;\n\t}\n\t// If the version doesn't match, send them this string\n\tNetMessage.TrySendData(2, this.whoAmI, text: Lang.mp[4].ToNetworkText());\n\tbreak;\n```\n\nSomething I haven't mentioned quite yet is that the Terraria server and client code is merged into one. The server is the same as the client but with `Main.dedServer = true`. This differentiation is made throughout the network code by checking if `Main.netMode` is 2. As far as I can tell 1 means client and 2 means server. There is also sometimes 0, which I believe represents a client that is not actively in a world? I'm not exactly sure and it doesn't seem to matter to us.\n\nI have set a password for the server, so it should be sending a type 37 packet, which it does. The client responds with 38 which presumably contains the password I inputted in Terraria. See if you can figure out what the string contains in the line `[c->s]: (38) 0870617373776f7264`.\n\nI think that's enough of explaining the protocol for now. There are so many different packets being sent, so I'll leave the explanation there for now.\n\n## Exploiting the Server\n\nEarlier, I did hint at changing the packet data while in transit. Well, an interesting one to change is the packet for putting an item in a chest. When the client puts an item in a chest, the following packet is received and handled by the server like so.\n\n```cs\ncase 32:\n\tint index28 = (int) this.reader.ReadInt16();\n\tint index29 = (int) this.reader.ReadByte();\n\tint num42 = (int) this.reader.ReadInt16();\n\tint prefixWeWant2 = (int) this.reader.ReadByte();\n\tint type6 = (int) this.reader.ReadInt16();\n\t// ... some sanity checks ...\n\tMain.chest[index28].item[index29].netDefaults(type6);\n\tMain.chest[index28].item[index29].Prefix(prefixWeWant2);\n\tMain.chest[index28].item[index29].stack = num42;\n\tRecipe.FindRecipes(true);\n\tbreak;\n```\n\nMaybe we can change the value of `stack` while in transit to put more items in the chest? Let's try it out by writing the following in our Python method from earlier.\n\n```py\nif data[0] == 32:\n\t# make data a bytearray so we can mutate it\n\tdata = bytearray(data)\n\t# note: message type byte + i16 + byte = 4 bytes\n\t# we want to overwrite bytes 4 and 5 with the new stack number\n\tdata[4:6] = int(999).to_bytes(2, 'little')\n```\n\nAnd that's it! Let's see what happens in-game.\n\n\u003Cvideo src=\"/trust-1-2.mp4\" type=\"video/mp4\" controls>\u003C/video>\n\nExiting and re-entering a chest gives us 999 of what we put in, even if the item isn't stackable. In general, the Terraria server seems to not do any anti-cheat prevention, so modifying packets works pretty often. The Terraria server does have a lot of anti-spam code to prevent clients from rapidly sending messages, projectiles, attack commands, placing blocks, and so on. I assume this is mainly to prevent other clients from crashing.\n\n## Recap\n\n- Terraria uses plain old TCP with no encryption.\n- Terraria is written in C#, for which there are many high-quality disassembly tools available.\n  - dotPeek is pretty good.\n- A Terraria server can't have more than 255 players since each player is represented by a byte identifier.\n- `Terraria.exe` and `TerrariaServer.exe` are very similar. One is just `Main.dedServer = true;` and the other is not.\n- Cheating is fine but crashing other clients is not.\n\n## Conclusion\n\nWe have a lot of work cut out for us. We have to handle [world (.wld) files](https://fileformat.fandom.com/wiki/WLD). We may even have to implement world generation! Or copy it if we're lazy. We may have to parse user files. We have a lot of different packet types to implement. Maybe even fluid simulation. Did you think this would be easy?? Anyway, thanks for reading. See you in [part 2](/blog/trust-2).\n",html:"\u003Cp>Greetings, traveler. Welcome to my series on attempting to implement a game server for \u003Ca href=\"https://store.steampowered.com/app/105600/Terraria/\">Terraria\u003C/a>, my personal favorite game.\u003C/p>\n\u003Ch2>Motivation\u003C/h2>\n\u003Cp>I played Terraria on my X-Box 360 in 2013, on my PC in 2015, and on my phone in 2016. The numbers might not be perfectly accurate, but it&#39;s safe to say that I really like the game. I purchased it three times, after all. Since 2018, I&#39;ve gradually become more interested in servers and reverse engineering.\u003C/p>\n\u003Cp>\u003Ca href=\"https://github.com/Pryaxis/TShock\">TShock\u003C/a> is a dedicated Terraria server that uses \u003Ca href=\"https://github.com/SignatureBeef/Open-Terraria-API\">Open Terraria API\u003C/a>, which rewrites and hooks into the original Terraria server binary to expose the internal Terraria C# API. It works well and is not a Terraria server written from scratch, but rather an extension to the original server.\u003C/p>\n\u003Cp>After a bit of searching, it appears that no one has actually fully written a Terraria server from scratch. Perhaps that&#39;s for a good reason and I&#39;m doing something stupid here. I wouldn&#39;t be surprised if someone has successfully done this before.\u003C/p>\n\u003Cp>I&#39;m still learning Rust, and I&#39;m quite far from basic competency, but I&#39;d like to reverse engineer the server protocol and create a \u003Cem>ðŸš€âš¡blazing fast ðŸš€âš¡\u003C/em> vanilla game server in Rust that I can connect to with the native Terraria client.\u003C/p>\n\u003Cp>Basically, I&#39;m doing this because I like Terraria. I like reverse engineering things. And I want to get better at Rust. I&#39;m not sure how I&#39;ll manage discussing implementation details, since most of it is pretty boring. I will try my best to make the content interesting. If you want to see the code, the repository will always be \u003Ca href=\"https://github.com/xDimGG/trust\">here\u003C/a>.\u003C/p>\n\u003Ch2>Choosing Our Method\u003C/h2>\n\u003Cp>We have two main ways that we can approach this.\u003C/p>\n\u003Col>\n\u003Cli>We can decompile the server executable that is shipped with the Steam game and figure out how it does everything.\u003C/li>\n\u003Cli>We can create a man-in-the-middle proxy server to capture the raw data being sent between client and server.\u003C/li>\n\u003C/ol>\n\u003Cp>Before jumping straight to a disassembler, we should check out what language Terraria is written in. If we google &quot;what is terraria written in&quot;, we can see that it&#39;s written in C#. C# can be decompiled by a variety of software, but my personal favorite is \u003Ca href=\"https://www.jetbrains.com/decompiler/\">dotPeek\u003C/a>, a free .NET decompiler and assembly browser.\u003C/p>\n\u003Ch2>Decompiling Executables\u003C/h2>\n\u003Cp>If we navigate to Steam, right click on Terraria, go to Properties, go to Local Files, and click Browse, Terraria&#39;s folder will open up. There exist two files of interest: \u003Ccode>Terraria.exe\u003C/code> and \u003Ccode>TerrariaServer.exe\u003C/code>. Let&#39;s go ahead and open up the latter in dotPeek. Expanding the Terraria element, we see a plethora of classes and namespaces. I prefer working in VS Code so I exported the project and opened up the folder in there.\u003C/p>\n\u003Cp>\u003Cimg src=\"/trust-1-1.png\" alt=\"vs code screenshot\">\u003C/p>\n\u003Cp>At least they&#39;re human readable. In here, there are two files that concern us. \u003Ccode>MessageBuffer.cs\u003C/code> and \u003Ccode>NetMessage.cs\u003C/code>. \u003Ccode>NetMessage.cs\u003C/code> has a \u003Ccode>SendData\u003C/code> method which takes some parameters and produces a binary message to be sent over the wire. \u003Ccode>MessageBuffer.cs\u003C/code> has a \u003Ccode>GetData\u003C/code> which uses its internal buffer to parse a binary message.\u003C/p>\n\u003Cp>Hold on. How did I pluck out these two methods out of the mess that is 100+ C# files? A lot of poking around is how. I skimmed through a few files and noticed that a lot of them were making calls to \u003Ccode>NetMessage.SendData\u003C/code> whenever some the client performs an action. After opening up the file, I found a huge switch statement, so I figured that this method probably had something to do with encoding. I found \u003Ccode>MessageBuffer.GetData\u003C/code> through more poking around. The name seemed important and it also had a huge switch statement. Anyway, here&#39;s a snippet of what \u003Ccode>NetMessage.SendData\u003C/code> looks like:\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-function\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> \u003Cspan class=\"hljs-keyword\">static\u003C/span> \u003Cspan class=\"hljs-keyword\">void\u003C/span> \u003Cspan class=\"hljs-title\">SendData\u003C/span>(\u003Cspan class=\"hljs-params\">\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> msgType,\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> remoteClient = \u003Cspan class=\"hljs-number\">-1\u003C/span>,\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> ignoreClient = \u003Cspan class=\"hljs-number\">-1\u003C/span>,\n    NetworkText text = \u003Cspan class=\"hljs-literal\">null\u003C/span>,\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> number = \u003Cspan class=\"hljs-number\">0\u003C/span>,\n    \u003Cspan class=\"hljs-comment\">/* 3 more floats and 3 more ints */\u003C/span>\n    \u003C/span>)\u003C/span> {\n        \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n        \u003Cspan class=\"hljs-comment\">// index to our own writer\u003C/span>\n        \u003Cspan class=\"hljs-built_in\">int\u003C/span> index1 = \u003Cspan class=\"hljs-number\">256\u003C/span>;\n        \u003Cspan class=\"hljs-comment\">// if we are server and are sending to some particular client, use their writer index\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (Main.netMode == \u003Cspan class=\"hljs-number\">2\u003C/span> &amp;&amp; remoteClient &gt;= \u003Cspan class=\"hljs-number\">0\u003C/span>)\n            index1 = remoteClient;\n\n        \u003Cspan class=\"hljs-keyword\">lock\u003C/span> (NetMessage.buffer[index1]) {\n            BinaryWriter writer = NetMessage.buffer[index1].writer; \u003Cspan class=\"hljs-comment\">// get the writer for this \u003C/span>\n            \u003Cspan class=\"hljs-keyword\">if\u003C/span> (writer == \u003Cspan class=\"hljs-literal\">null\u003C/span>) {\n                NetMessage.buffer[index1].ResetWriter();\n                writer = NetMessage.buffer[index1].writer;\n            }\n            \u003Cspan class=\"hljs-built_in\">long\u003C/span> position1 = writer.BaseStream.Position; \u003Cspan class=\"hljs-comment\">// get our current position\u003C/span>\n            writer.BaseStream.Position += \u003Cspan class=\"hljs-number\">2L\u003C/span>; \u003Cspan class=\"hljs-comment\">// skip the first two bytes\u003C/span>\n            writer.Write((\u003Cspan class=\"hljs-built_in\">byte\u003C/span>) msgType); \u003Cspan class=\"hljs-comment\">// write a byte containing the message type\u003C/span>\n            \u003Cspan class=\"hljs-keyword\">switch\u003C/span> (msgType) { \u003Cspan class=\"hljs-comment\">// perform the rest of the encoding based on the message type\u003C/span>\n                \u003Cspan class=\"hljs-keyword\">case\u003C/span> \u003Cspan class=\"hljs-number\">1\u003C/span>:\n                    writer.Write(\u003Cspan class=\"hljs-string\">&quot;Terraria&quot;\u003C/span> + (\u003Cspan class=\"hljs-built_in\">object\u003C/span>) \u003Cspan class=\"hljs-number\">279\u003C/span>);\n                    \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n                \u003Cspan class=\"hljs-keyword\">case\u003C/span> \u003Cspan class=\"hljs-number\">2\u003C/span>:\n                    \u003Cspan class=\"hljs-comment\">// ... all the way up to 147 as of Terraria 1.4.4.9\u003C/span>\n            }\n            \u003Cspan class=\"hljs-built_in\">int\u003C/span> position2 = (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) writer.BaseStream.Position; \u003Cspan class=\"hljs-comment\">// get the current length of our data\u003C/span>\n            writer.BaseStream.Position = position1; \u003Cspan class=\"hljs-comment\">// set our buffer position to the start\u003C/span>\n            writer.Write((\u003Cspan class=\"hljs-built_in\">ushort\u003C/span>) position2); \u003Cspan class=\"hljs-comment\">// write our length as the first two bytes\u003C/span>\n            writer.BaseStream.Position = (\u003Cspan class=\"hljs-built_in\">long\u003C/span>) position2; \u003Cspan class=\"hljs-comment\">// move our cursor back to the end\u003C/span>\n            \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n        }\n    }\n\u003C/code>\u003C/pre>\u003Cp>If we go back to \u003Ccode>NetMessage\u003C/code>, we can find the following line defining \u003Ccode>buffer\u003C/code>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-keyword\">public\u003C/span> BinaryWriter writer;\n\u003C/code>\u003C/pre>\u003Cp>\u003Ccode>BinaryWriter\u003C/code> is just a standard .NET class whose documentation can be found \u003Ca href=\"https://learn.microsoft.com/en-us/dotnet/api/system.io.binarywriter.write\">here\u003C/a>. If we read the documentation, we see that numbers are written using \u003Ca href=\"https://betterexplained.com/articles/understanding-big-and-little-endian-byte-order/\">little endian byte ordering\u003C/a>. That&#39;s enough C# for now. Let&#39;s create a man-in-the-middle proxy server.\u003C/p>\n\u003Ch2>Making an MITM Proxy to Decode Messages\u003C/h2>\n\u003Cp>For those who are not familiar, man-in-the-middle means we will have a server that sits between the client and the server and handles communication. Proxy means we&#39;re just passing the information down. What we&#39;ll have to do to get this working is start up a legitimate Terraria server on some port, say 7778, and start our proxy server on some other port, say 7777, and have the Terraria client conect to our proxy on port 7777. The proxy will receive data from the client and send it to the server and vice versa.\u003C/p>\n\u003Cp>While the packet is in transit, we can log it to see what kind of interesting packets are being sent. This gives us a high-level view of the protocol and will make it easier to figure out what to look for in the C# files. \u003Cem>Spoiler: we may also modify the packet while it is in transit to produce some interesting behavior on the client and server.\u003C/em>\u003C/p>\n\u003Cp>For this part, I&#39;ll just be using Python. It&#39;s a good language for prototyping this kinda of thing. First off, let&#39;s define our ports and hosts. Everything we&#39;re doing will be on localhost so I&#39;m just using one constant to represent both.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">HOST = \u003Cspan class=\"hljs-string\">&#x27;127.0.0.1&#x27;\u003C/span> \u003Cspan class=\"hljs-comment\"># localhost\u003C/span>\nPORT = \u003Cspan class=\"hljs-number\">7777\u003C/span>  \u003Cspan class=\"hljs-comment\"># Port to listen on (non-privileged ports are &gt; 1023)\u003C/span>\nREAL_PORT = \u003Cspan class=\"hljs-number\">7778\u003C/span> \u003Cspan class=\"hljs-comment\"># Port on which the actual Terraria server is already running\u003C/span>\n\u003C/code>\u003C/pre>\u003Cp>Now, let&#39;s create a TCP server that can handle multiple clients. Handling multiple clients won&#39;t be necessary for a while, but it&#39;s nice to have.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">import\u003C/span> socket\n\u003Cspan class=\"hljs-keyword\">from\u003C/span> threading \u003Cspan class=\"hljs-keyword\">import\u003C/span> Thread\n\n\u003Cspan class=\"hljs-keyword\">def\u003C/span> \u003Cspan class=\"hljs-title function_\">start_proxy\u003C/span>(\u003Cspan class=\"hljs-params\">client\u003C/span>):\n    \u003Cspan class=\"hljs-keyword\">try\u003C/span>:\n        \u003Cspan class=\"hljs-keyword\">with\u003C/span> client:\n            \u003Cspan class=\"hljs-keyword\">with\u003C/span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) \u003Cspan class=\"hljs-keyword\">as\u003C/span> server:\n                server.connect((HOST, REAL_PORT))\n\n                threads = [ \u003Cspan class=\"hljs-comment\"># we will define copy() in a moment\u003C/span>\n                    Thread(target=copy, args=(client, server, \u003Cspan class=\"hljs-string\">&#x27;[c-&gt;s]:&#x27;\u003C/span>)),\n                    Thread(target=copy, args=(server, client, \u003Cspan class=\"hljs-string\">&#x27;[s-&gt;c]:&#x27;\u003C/span>)),\n                ]\n                \u003Cspan class=\"hljs-keyword\">for\u003C/span> t \u003Cspan class=\"hljs-keyword\">in\u003C/span> threads: t.start()\n                \u003Cspan class=\"hljs-keyword\">for\u003C/span> t \u003Cspan class=\"hljs-keyword\">in\u003C/span> threads: t.join()\n\n        \u003Cspan class=\"hljs-built_in\">print\u003C/span>(\u003Cspan class=\"hljs-string\">f&#x27;Client has disconnected or true server stopped&#x27;\u003C/span>)\n    \u003Cspan class=\"hljs-keyword\">except\u003C/span>:\n        \u003Cspan class=\"hljs-keyword\">pass\u003C/span>\n\n\u003Cspan class=\"hljs-keyword\">with\u003C/span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) \u003Cspan class=\"hljs-keyword\">as\u003C/span> s:\n    s.bind((HOST, PORT))\n    s.listen()\n    \u003Cspan class=\"hljs-built_in\">print\u003C/span>(\u003Cspan class=\"hljs-string\">f&#x27;Proxy started on port \u003Cspan class=\"hljs-subst\">{PORT}\u003C/span>&#x27;\u003C/span>)\n\n    \u003Cspan class=\"hljs-keyword\">while\u003C/span> \u003Cspan class=\"hljs-literal\">True\u003C/span>:\n        conn, addr = s.accept()\n        \u003Cspan class=\"hljs-built_in\">print\u003C/span>(\u003Cspan class=\"hljs-string\">f&#x27;Client \u003Cspan class=\"hljs-subst\">{addr}\u003C/span> has connected&#x27;\u003C/span>)\n        t = Thread(target=start_proxy, args=(conn, ))\n        t.start()\n\u003C/code>\u003C/pre>\u003Cp>What is the code doing? Well, we&#39;re creating a \u003Ccode>socket.socket\u003C/code> as \u003Ccode>s\u003C/code>. We pass in \u003Ccode>socket.AF_INET\u003C/code> since we are using IPv4 and \u003Ccode>socket.SOCK_STREAM\u003C/code> since we are using TCP. Based on what I know about game servers, it is likely that Terraria uses TCP. We could make sure of it by using Wireshark, but this is most likely the case.\u003C/p>\n\u003Cp>Next, we are binding to 127.0.0.1:7777 and calling listen since we are a server. Then we enter an loop where we try to accept incoming connections. \u003Ccode>accept\u003C/code> is blocking so nothing happens until someone connects. When someone has connected, we may start a thread for them and pass the connection as an argument. We don&#39;t join this thread since we want to be ready for the next client.\u003C/p>\n\u003Cp>The \u003Ccode>start_proxy\u003C/code> function takes a client connection and creates the &quot;real&quot; connection with the Terraria server. Our process is now acting as a client, and we can forward messages to and from the server by using the copy() function which we are about to define. \u003Cem>Note: \u003Ccode>try: ... except: pass\u003C/code> is used so that our process doesn&#39;t crash when someone disconnects or the real server shuts down.\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">def\u003C/span> \u003Cspan class=\"hljs-title function_\">copy\u003C/span>(\u003Cspan class=\"hljs-params\">src, dst, prefix\u003C/span>):\n    \u003Cspan class=\"hljs-keyword\">try\u003C/span>:\n        \u003Cspan class=\"hljs-keyword\">while\u003C/span> \u003Cspan class=\"hljs-literal\">True\u003C/span>:\n            \u003Cspan class=\"hljs-comment\"># try getting the bytes representing the length of the packet\u003C/span>\n            data_size = src.recv(\u003Cspan class=\"hljs-number\">2\u003C/span>)\n            \u003Cspan class=\"hljs-keyword\">if\u003C/span> \u003Cspan class=\"hljs-keyword\">not\u003C/span> data_size:\n                \u003Cspan class=\"hljs-keyword\">break\u003C/span>\n\n            \u003Cspan class=\"hljs-comment\"># parse the bytes to an int using LE ordering\u003C/span>\n            \u003Cspan class=\"hljs-comment\"># minus 2 since we&#x27;re excluding the first two bytes we read\u003C/span>\n            size = \u003Cspan class=\"hljs-built_in\">int\u003C/span>.from_bytes(data_size, \u003Cspan class=\"hljs-string\">&#x27;little&#x27;\u003C/span>) - \u003Cspan class=\"hljs-number\">2\u003C/span>\n            \u003Cspan class=\"hljs-comment\"># try getting the rest of the packet\u003C/span>\n            data = src.recv(size)\n            \u003Cspan class=\"hljs-keyword\">if\u003C/span> \u003Cspan class=\"hljs-keyword\">not\u003C/span> data:\n                \u003Cspan class=\"hljs-keyword\">break\u003C/span>\n\n            \u003Cspan class=\"hljs-comment\"># data[0] is our message code\u003C/span>\n            \u003Cspan class=\"hljs-comment\"># data[1:] is the encoded message\u003C/span>\n            \u003Cspan class=\"hljs-built_in\">print\u003C/span>(\u003Cspan class=\"hljs-string\">f&#x27;\u003Cspan class=\"hljs-subst\">{prefix}\u003C/span> (\u003Cspan class=\"hljs-subst\">{data[\u003Cspan class=\"hljs-number\">0\u003C/span>]}\u003C/span>) \u003Cspan class=\"hljs-subst\">{data[\u003Cspan class=\"hljs-number\">1\u003C/span>:].\u003Cspan class=\"hljs-built_in\">hex\u003C/span>()}\u003C/span>&#x27;\u003C/span>)\n            \u003Cspan class=\"hljs-comment\"># forward the message to the receiver\u003C/span>\n            dst.sendall(data_size + data)\n    \u003Cspan class=\"hljs-keyword\">except\u003C/span>:\n        \u003Cspan class=\"hljs-keyword\">pass\u003C/span>\n\u003C/code>\u003C/pre>\u003Cp>With that in place and running, we can now start a real Terraria server on port 7778 and connect with the Terraria client to port 7777. The game looks and plays as it normally does, but in the background we are now logging all of the packets being transmitted. Here&#39;s what the console looks like:\u003C/p>\n\u003Cpre>\u003Ccode>Proxy started on port 7777\nClient (&#x27;127.0.0.1&#x27;, 51183) has connected\n[c-&gt;s]: (1) 0b5465727261726961323739\n[s-&gt;c]: (37) \n[c-&gt;s]: (38) 0870617373776f7264\n[s-&gt;c]: (3) 0100\n[c-&gt;s]: (4) 0103890364696d00000000fbfbfaf57f5e421c32e5cfd6eadbf6b2bbb8e0abfd001000\n[c-&gt;s]: (68) 2430336439363837622d623631372d346435642d396161322d623739316461356332346233\n[c-&gt;s]: (16) 0190019001\n[c-&gt;s]: (42) 0114001400\n...\n\u003C/code>\u003C/pre>\u003Cp>So, the client starts by send a type 1 message with some data after it. Let&#39;s recall the C# we looked at earlier.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-keyword\">case\u003C/span> \u003Cspan class=\"hljs-number\">1\u003C/span>:\n    writer.Write(\u003Cspan class=\"hljs-string\">&quot;Terraria&quot;\u003C/span> + (\u003Cspan class=\"hljs-built_in\">object\u003C/span>) \u003Cspan class=\"hljs-number\">279\u003C/span>);\n    \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n\u003C/code>\u003C/pre>\u003Cp>It seems that the message contains Terraria279. I&#39;m guessing \u003Ccode>0b\u003C/code> is the length of the string and \u003Ccode>5465727261726961323739\u003C/code> is the string (after being hex encoded). \u003Ccode>Terraria279\u003C/code> is 11 digits long and 11 in hex is B so that checks out. Using \u003Ca href=\"https://www.rapidtables.com/convert/number/hex-to-ascii.html\">this site\u003C/a>, you can convert the hex string to ASCII and see the result. Go on, give it a shot.\u003C/p>\n\u003Cp>Okay, so the client first tells the server what version they&#39;re running and if it&#39;s compatible, the server responds with a type 37 message. Let&#39;s look at the logic for when the server reads a type 1 message from the client. \u003Cem>Remember, message decoding is done by \u003Ccode>MessageBuffer.GetData\u003C/code>.\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-keyword\">case\u003C/span> \u003Cspan class=\"hljs-number\">1\u003C/span>:\n    \u003Cspan class=\"hljs-comment\">// If we are not a server, ignore this packet.\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> (Main.netMode != \u003Cspan class=\"hljs-number\">2\u003C/span>) \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n    \u003Cspan class=\"hljs-comment\">// Check if this player is IP banned\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> (Main.dedServ &amp;&amp; Netplay.IsBanned(Netplay.Clients[\u003Cspan class=\"hljs-keyword\">this\u003C/span>.whoAmI].Socket.GetRemoteAddress())) {\n        \u003Cspan class=\"hljs-comment\">// Send the player a localization key informing them they are banned\u003C/span>\n        NetMessage.TrySendData(\u003Cspan class=\"hljs-number\">2\u003C/span>, \u003Cspan class=\"hljs-keyword\">this\u003C/span>.whoAmI, text: Lang.mp[\u003Cspan class=\"hljs-number\">3\u003C/span>].ToNetworkText());\n        \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n    }\n    \u003Cspan class=\"hljs-comment\">// If this client is not on the state 0\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> (Netplay.Clients[\u003Cspan class=\"hljs-keyword\">this\u003C/span>.whoAmI].State != \u003Cspan class=\"hljs-number\">0\u003C/span>) \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> (\u003Cspan class=\"hljs-keyword\">this\u003C/span>.reader.ReadString() == \u003Cspan class=\"hljs-string\">&quot;Terraria&quot;\u003C/span> + (\u003Cspan class=\"hljs-built_in\">object\u003C/span>) \u003Cspan class=\"hljs-number\">279\u003C/span>) {\n        \u003Cspan class=\"hljs-comment\">// If there is no server password, send the client packet 3 and set their state to 1\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> (\u003Cspan class=\"hljs-built_in\">string\u003C/span>.IsNullOrEmpty(Netplay.ServerPassword)) {\n            Netplay.Clients[\u003Cspan class=\"hljs-keyword\">this\u003C/span>.whoAmI].State = \u003Cspan class=\"hljs-number\">1\u003C/span>;\n            NetMessage.TrySendData(\u003Cspan class=\"hljs-number\">3\u003C/span>, \u003Cspan class=\"hljs-keyword\">this\u003C/span>.whoAmI);\n            \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n        }\n        \u003Cspan class=\"hljs-comment\">// If there is a password, set the client&#x27;s state to -1 and send them packet 37\u003C/span>\n        Netplay.Clients[\u003Cspan class=\"hljs-keyword\">this\u003C/span>.whoAmI].State = \u003Cspan class=\"hljs-number\">-1\u003C/span>;\n        NetMessage.TrySendData(\u003Cspan class=\"hljs-number\">37\u003C/span>, \u003Cspan class=\"hljs-keyword\">this\u003C/span>.whoAmI);\n        \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n    }\n    \u003Cspan class=\"hljs-comment\">// If the version doesn&#x27;t match, send them this string\u003C/span>\n    NetMessage.TrySendData(\u003Cspan class=\"hljs-number\">2\u003C/span>, \u003Cspan class=\"hljs-keyword\">this\u003C/span>.whoAmI, text: Lang.mp[\u003Cspan class=\"hljs-number\">4\u003C/span>].ToNetworkText());\n    \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n\u003C/code>\u003C/pre>\u003Cp>Something I haven&#39;t mentioned quite yet is that the Terraria server and client code is merged into one. The server is the same as the client but with \u003Ccode>Main.dedServer = true\u003C/code>. This differentiation is made throughout the network code by checking if \u003Ccode>Main.netMode\u003C/code> is 2. As far as I can tell 1 means client and 2 means server. There is also sometimes 0, which I believe represents a client that is not actively in a world? I&#39;m not exactly sure and it doesn&#39;t seem to matter to us.\u003C/p>\n\u003Cp>I have set a password for the server, so it should be sending a type 37 packet, which it does. The client responds with 38 which presumably contains the password I inputted in Terraria. See if you can figure out what the string contains in the line \u003Ccode>[c-&gt;s]: (38) 0870617373776f7264\u003C/code>.\u003C/p>\n\u003Cp>I think that&#39;s enough of explaining the protocol for now. There are so many different packets being sent, so I&#39;ll leave the explanation there for now.\u003C/p>\n\u003Ch2>Exploiting the Server\u003C/h2>\n\u003Cp>Earlier, I did hint at changing the packet data while in transit. Well, an interesting one to change is the packet for putting an item in a chest. When the client puts an item in a chest, the following packet is received and handled by the server like so.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-cs\">\u003Cspan class=\"hljs-keyword\">case\u003C/span> \u003Cspan class=\"hljs-number\">32\u003C/span>:\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> index28 = (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) \u003Cspan class=\"hljs-keyword\">this\u003C/span>.reader.ReadInt16();\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> index29 = (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) \u003Cspan class=\"hljs-keyword\">this\u003C/span>.reader.ReadByte();\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> num42 = (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) \u003Cspan class=\"hljs-keyword\">this\u003C/span>.reader.ReadInt16();\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> prefixWeWant2 = (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) \u003Cspan class=\"hljs-keyword\">this\u003C/span>.reader.ReadByte();\n    \u003Cspan class=\"hljs-built_in\">int\u003C/span> type6 = (\u003Cspan class=\"hljs-built_in\">int\u003C/span>) \u003Cspan class=\"hljs-keyword\">this\u003C/span>.reader.ReadInt16();\n    \u003Cspan class=\"hljs-comment\">// ... some sanity checks ...\u003C/span>\n    Main.chest[index28].item[index29].netDefaults(type6);\n    Main.chest[index28].item[index29].Prefix(prefixWeWant2);\n    Main.chest[index28].item[index29].stack = num42;\n    Recipe.FindRecipes(\u003Cspan class=\"hljs-literal\">true\u003C/span>);\n    \u003Cspan class=\"hljs-keyword\">break\u003C/span>;\n\u003C/code>\u003C/pre>\u003Cp>Maybe we can change the value of \u003Ccode>stack\u003C/code> while in transit to put more items in the chest? Let&#39;s try it out by writing the following in our Python method from earlier.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">if\u003C/span> data[\u003Cspan class=\"hljs-number\">0\u003C/span>] == \u003Cspan class=\"hljs-number\">32\u003C/span>:\n    \u003Cspan class=\"hljs-comment\"># make data a bytearray so we can mutate it\u003C/span>\n    data = \u003Cspan class=\"hljs-built_in\">bytearray\u003C/span>(data)\n    \u003Cspan class=\"hljs-comment\"># note: message type byte + i16 + byte = 4 bytes\u003C/span>\n    \u003Cspan class=\"hljs-comment\"># we want to overwrite bytes 4 and 5 with the new stack number\u003C/span>\n    data[\u003Cspan class=\"hljs-number\">4\u003C/span>:\u003Cspan class=\"hljs-number\">6\u003C/span>] = \u003Cspan class=\"hljs-built_in\">int\u003C/span>(\u003Cspan class=\"hljs-number\">999\u003C/span>).to_bytes(\u003Cspan class=\"hljs-number\">2\u003C/span>, \u003Cspan class=\"hljs-string\">&#x27;little&#x27;\u003C/span>)\n\u003C/code>\u003C/pre>\u003Cp>And that&#39;s it! Let&#39;s see what happens in-game.\u003C/p>\n\u003Cp>\u003Cvideo src=\"/trust-1-2.mp4\" type=\"video/mp4\" controls>\u003C/video>\u003C/p>\n\u003Cp>Exiting and re-entering a chest gives us 999 of what we put in, even if the item isn&#39;t stackable. In general, the Terraria server seems to not do any anti-cheat prevention, so modifying packets works pretty often. The Terraria server does have a lot of anti-spam code to prevent clients from rapidly sending messages, projectiles, attack commands, placing blocks, and so on. I assume this is mainly to prevent other clients from crashing.\u003C/p>\n\u003Ch2>Recap\u003C/h2>\n\u003Cul>\n\u003Cli>Terraria uses plain old TCP with no encryption.\u003C/li>\n\u003Cli>Terraria is written in C#, for which there are many high-quality disassembly tools available.\u003Cul>\n\u003Cli>dotPeek is pretty good.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>A Terraria server can&#39;t have more than 255 players since each player is represented by a byte identifier.\u003C/li>\n\u003Cli>\u003Ccode>Terraria.exe\u003C/code> and \u003Ccode>TerrariaServer.exe\u003C/code> are very similar. One is just \u003Ccode>Main.dedServer = true;\u003C/code> and the other is not.\u003C/li>\n\u003Cli>Cheating is fine but crashing other clients is not.\u003C/li>\n\u003C/ul>\n\u003Ch2>Conclusion\u003C/h2>\n\u003Cp>We have a lot of work cut out for us. We have to handle \u003Ca href=\"https://fileformat.fandom.com/wiki/WLD\">world (.wld) files\u003C/a>. We may even have to implement world generation! Or copy it if we&#39;re lazy. We may have to parse user files. We have a lot of different packet types to implement. Maybe even fluid simulation. Did you think this would be easy?? Anyway, thanks for reading. See you in \u003Ca href=\"/blog/trust-2\">part 2\u003C/a>.\u003C/p>\n",title:"Exploring Terraria's Server Protocol (trust pt. 1)",date:1707490172482,tags:["python","reverse-engineering","tcp","trust"]},"uses":{"params":["id"]}}];

					Promise.all([
						import("../../_app/immutable/entry/start.08ee98e4.js"),
						import("../../_app/immutable/entry/app.515171e9.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
