<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../favicon.jpeg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" integrity="sha512-c42qTSw/wPZ3/5LBzD+Bw5f7bSF2oxou6wEb+I/lqeaKV5FDIfMvvRp772y4jcJLKuGUOpbJMdg/BTl50fJYAw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
		
		<link href="../../_app/immutable/assets/0.28caa243.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/4.2a853ecf.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.b0cd14ac.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/scheduler.e108d1fd.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/singletons.7ba481ac.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.a8956f14.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index.48054bed.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.8502b51e.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/4.d75ab359.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/each.e59479a4.js"><title>Writing Sweet Rust Macros (trust pt. 2)</title><!-- HEAD_svelte-1n6ckfq_START --><link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet"><!-- HEAD_svelte-1n6ckfq_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">   <div class="min-h-screen w-full dark:bg-slate-900 px-3 py-8"><div class="prose prose-img:max-h-[80vh] prose-img:mx-auto prose-code:break-words prose-gray dark:prose-invert lg:max-w-[1000px] mx-auto"><div class="flex justify-between"><h1 class="mb-0">Writing Sweet Rust Macros (trust pt. 2)</h1> <div class="block text-xs text-right text-opacity-50 shrink-0 ml-2"><a href="/blog/" class="xt-slate-500 dark:text-white block no-underline hover:underline" data-svelte-h="svelte-6j3ym0">other posts</a> <span class="text-slate-500 dark:text-slate-400">2/13/2024</span></div></div> <a href="/blog/?tag=macros" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">macros</a><span class="text-slate-500 dark:text-slate-400">, </span><a href="/blog/?tag=rust" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">rust</a><span class="text-slate-500 dark:text-slate-400">, </span><a href="/blog/?tag=trust" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">trust</a><span class="text-slate-500 dark:text-slate-400"></span> <!-- HTML_TAG_START --><p>There is something I haven&#39;t told you yet about trust in <a href="/blog/trust-1">part 1</a>. It is actually a project that I had thought of 2 years ago. Back then, I wanted to do the same thing as what I&#39;m doing now, but I quit once I realized the actual scale of this project. As it turns out, this isn&#39;t an easy project. At the beginning, I found it strange that the Terraria server is just a headless client (meaning the server treats itself as an &quot;invisible&quot; player in the server). After really thinking about it, it makes plenty of sense. All of the game logic (mob spawning, water flowing, entity interactions) have to be fired off by some central authority — the server — and this means we need Terraria&#39;s logic, spawn rates, etc. all in our code. This is definitely a lot to implement and what halted my progress the first time. To put it short, I felt like I was about to open Pandora&#39;s box. I didn&#39;t like that feeling of uncertainty and rather than even begin to start, I gave up then and there. Alas, we are back and my mentality has greatly shifted since then.</p>
<blockquote>
<p>The struggle itself towards the heights is enough to fill a man&#39;s heart. One must imagine Sisyphus happy.</p>
</blockquote>
<h2>Why a Macro?</h2>
<p>Ok, so we have a fairly structured network protocol at this point. Each packet is structured like so.</p>
<table>
<thead>
<tr>
<th>field</th>
<th>type</th>
<th>length</th>
</tr>
</thead>
<tbody><tr>
<td>len</td>
<td>u16</td>
<td>2</td>
</tr>
<tr>
<td>code</td>
<td>u8</td>
<td>1</td>
</tr>
<tr>
<td>msg</td>
<td>bytes</td>
<td>len-3</td>
</tr>
</tbody></table>
<p>Depending on <code>code</code>, <code>msg</code> may contain certain fields. For instance, if <code>code</code> is 3, we have a connection approval message whose fields are contained in <code>msg</code> like so.</p>
<table>
<thead>
<tr>
<th>field</th>
<th>type</th>
<th>length</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>u8</td>
<td>1</td>
</tr>
<tr>
<td>flag</td>
<td>bool</td>
<td>1</td>
</tr>
</tbody></table>
<p><code>id</code> represents the ID that the server assigns the user and <code>flag</code> seems to represent a flag called <code>ServerWantsToRunCheckBytesInClientLoopThread</code>. If this is true, the client calls <code>NetMessage.CheckBytes()</code> inside <code>Main.InnerClientLoop()</code>. Don&#39;t ask me... all I know is that this is hardcoded to be <code>false</code> every time.</p>
<p>Let&#39;s take another example. If <code>code</code> is 5 and client-sent, the client is updating the server about a particular slot in their inventory. If <code>code</code> is 5 and broadcasted by the server, the server is notifying all players of a change in a player&#39;s inventory. <em>Note: internally, an inventory represents all a players items including their armor, dyes, pets, mounts, etc. Not just the items in the top left of their escape menu.</em></p>
<table>
<thead>
<tr>
<th>field</th>
<th>type</th>
<th>length</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>u8</td>
<td>1</td>
</tr>
<tr>
<td>slot_id</td>
<td>i16</td>
<td>2</td>
</tr>
<tr>
<td>amount</td>
<td>i16</td>
<td>2</td>
</tr>
<tr>
<td>prefix</td>
<td>u8</td>
<td>1</td>
</tr>
<tr>
<td>item_id</td>
<td>i16</td>
<td>2</td>
</tr>
</tbody></table>
<p>You get the gist? Anyway, my goal was to be able to write a Rust enum representing each packet so we can use <code>match</code>. I also want it to be aware of the code of each packet to automatically parse and encode it. In the doc comment, I put the packet&#39;s code. Also, let&#39;s not create the read method for server-only packets and write for client-only packets. In the doc comment, <code>-&gt;</code> means send-only, <code>&lt;-</code> means receive-only, and <code>&lt;-&gt;</code> means bidirectional. That would mean our macro should be able to convert this.</p>
<pre><code class="hljs language-rs"><span class="hljs-meta">#[our_cool_proc_macro]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
    <span class="hljs-comment">/// 3 -&gt;</span>
    ConnectionApprove {
        client_id: <span class="hljs-type">u8</span>,
        flag: <span class="hljs-type">bool</span>,
    },
    <span class="hljs-comment">/// 5 &lt;-&gt;</span>
    PlayerInventorySlot {
        client_id: <span class="hljs-type">u8</span>,
        slot_id: <span class="hljs-type">i16</span>,
        amount: <span class="hljs-type">i16</span>,
        prefix: <span class="hljs-type">u8</span>,
        item_id: <span class="hljs-type">i16</span>,
    },
}
</code></pre><p>into this</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ConnectionApprove</span> {
    <span class="hljs-keyword">pub</span> client_id: <span class="hljs-type">u8</span>,
    <span class="hljs-keyword">pub</span> flag: <span class="hljs-type">bool</span>,
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PlayerInventorySlot</span> {
    <span class="hljs-keyword">pub</span> client_id: <span class="hljs-type">u8</span>,
    <span class="hljs-keyword">pub</span> slot_id: <span class="hljs-type">i16</span>,
    <span class="hljs-keyword">pub</span> amount: <span class="hljs-type">i16</span>,
    <span class="hljs-keyword">pub</span> prefix: <span class="hljs-type">u8</span>,
    <span class="hljs-keyword">pub</span> item_id: <span class="hljs-type">i16</span>,
}

<span class="hljs-meta">#[our_cool_proc_macro]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
    <span class="hljs-title function_ invoke__">ConnectionApprove</span>(ConnectionApprove),
    <span class="hljs-title function_ invoke__">PlayerInventorySlot</span>(PlayerInventorySlot),
    <span class="hljs-title function_ invoke__">Unknown</span>(<span class="hljs-type">u8</span>, &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-type">u8</span>]),
}

<span class="hljs-comment">// let&#x27;s assume the caller has already read the length of the packet and</span>
<span class="hljs-comment">// is giving us everything after the length</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">buffer_to_message</span>(buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> Message {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = Reader::<span class="hljs-title function_ invoke__">new</span>(buf); <span class="hljs-comment">// create a byte reader</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">code</span> = r.<span class="hljs-title function_ invoke__">read_byte</span>();
    <span class="hljs-keyword">match</span> code {
        <span class="hljs-number">5</span> =&gt; Message::<span class="hljs-title function_ invoke__">PlayerInventorySlot</span>(PlayerInventorySlot {
            client_id: r.<span class="hljs-title function_ invoke__">read_byte</span>(),
            slot_id: r.<span class="hljs-title function_ invoke__">read_i16</span>(),
            amount: r.<span class="hljs-title function_ invoke__">read_i16</span>(),
            prefix: r.<span class="hljs-title function_ invoke__">read_byte</span>(),
            item_id: r.<span class="hljs-title function_ invoke__">read_i16</span>(),
        }),
        _ =&gt; Message::<span class="hljs-title function_ invoke__">Unknown</span>(code, &amp;buf[<span class="hljs-number">1</span>..])
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">message_to_buffer</span>(msg: Message) <span class="hljs-punctuation">-&gt;</span> &amp;[<span class="hljs-type">u8</span>] {
    <span class="hljs-keyword">match</span> Message {
        Message::<span class="hljs-title function_ invoke__">ConnectionApprove</span>(ca) =&gt; {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = Writer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);
            w.<span class="hljs-title function_ invoke__">write_byte</span>(client_id);
            w.<span class="hljs-title function_ invoke__">write_bool</span>(flag);
            w.<span class="hljs-title function_ invoke__">finalize</span>() <span class="hljs-comment">// sets the first two bytes as the length and returns byte array</span>
        }
        Message::<span class="hljs-title function_ invoke__">PlayerInventorySlot</span>(slot) =&gt; {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = Writer::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);
            w.<span class="hljs-title function_ invoke__">write_byte</span>(slot.client_id);
            w.<span class="hljs-title function_ invoke__">write_i16</span>(slot.slot_id);
            w.<span class="hljs-title function_ invoke__">write_i16</span>(slot.amount);
            w.<span class="hljs-title function_ invoke__">write_byte</span>(slot.prefix);
            w.<span class="hljs-title function_ invoke__">write_i16</span>(slot.item_id);
            w.<span class="hljs-title function_ invoke__">finalize</span>()
        }
        _ =&gt; Message::<span class="hljs-title function_ invoke__">Unknown</span>(code, &amp;buf[<span class="hljs-number">1</span>..])
    }
}
</code></pre><p>In case you&#39;re wondering why I don&#39;t want to write the structs outside of the enum myself, it&#39;s because if I do, then this macro will be much more complicated as it won&#39;t just be completely contained within one enum.</p>
<h2>Binary Reader and Writer</h2>
<p>For starters, let&#39;s implement our <code>Reader</code> and <code>Writer</code>. Our reader will look like this,</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; Reader&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(buf: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> { buf, cur: <span class="hljs-number">0</span> }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_bytes</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, amount: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> &amp;[<span class="hljs-type">u8</span>] {
        <span class="hljs-keyword">self</span>.cur += amount;
        &amp;<span class="hljs-keyword">self</span>.buf[(<span class="hljs-keyword">self</span>.cur - amount)..<span class="hljs-keyword">self</span>.cur]
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_byte</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, amount: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> {
        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">read_bytes</span>(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_i16</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i16</span> {
        <span class="hljs-type">i16</span>::<span class="hljs-title function_ invoke__">from_le_bytes</span>(<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">read_bytes</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">try_into</span>().<span class="hljs-title function_ invoke__">unwrap</span>())
    }

    <span class="hljs-comment">// add methods as needed</span>
}
</code></pre><p>and our writer will look like this,</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Writer</span> {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(code: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> { buf: <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, code] } <span class="hljs-comment">// start the buffer with two empty bytes and the message code</span>
    }

    <span class="hljs-comment">// method to be called when a packet is done being constructed</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">finalize</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt; {
        <span class="hljs-keyword">let</span> [a, b] = (<span class="hljs-keyword">self</span>.buf.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u16</span>).<span class="hljs-title function_ invoke__">to_le_bytes</span>(); <span class="hljs-comment">// convert the length of the buffer to 2 bytes</span>
        <span class="hljs-keyword">self</span>.buf[<span class="hljs-number">0</span>] = a; <span class="hljs-comment">// replace the first two bytes with the length of the array</span>
        <span class="hljs-keyword">self</span>.buf[<span class="hljs-number">1</span>] = b;
        <span class="hljs-keyword">self</span>.buf
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_bytes</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, bytes: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">self</span>.buf.<span class="hljs-title function_ invoke__">append</span>(&amp;<span class="hljs-keyword">mut</span> bytes.<span class="hljs-title function_ invoke__">to_vec</span>());
        <span class="hljs-keyword">self</span>
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_byte</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, byte: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">self</span>.buf.<span class="hljs-title function_ invoke__">push</span>(byte);
        <span class="hljs-keyword">self</span>
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_i16</span>(<span class="hljs-keyword">self</span>, num: <span class="hljs-type">i16</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">write_bytes</span>(&amp;num.<span class="hljs-title function_ invoke__">to_le_bytes</span>())
    }

    <span class="hljs-comment">// add methods as needed</span>
}
</code></pre><p>Makes sense? I&#39;m just trying to get through this quickly since this is mostly boilerplate for the real difficulty which is writing a procedural macro.</p>
<p>As per The Rust Reference,</p>
<blockquote>
<p>Procedural macros allow you to run code at compile time that operates over Rust syntax, both consuming and producing Rust syntax. You can sort of think of procedural macros as functions from an AST to another AST.</p>
</blockquote>
<h2>Set Up a Project for the Macro</h2>
<p>So, we want to parse the AST and generate our own AST. Let&#39;s create a new cargo project called macros (<code>cargo init macros --lib</code>) and include in our main project (which actually hasn&#39;t been established yet) by adding <code>macros = { path = &quot;macros&quot; }</code> to <code>Cargo.toml</code>. In the <code>macros</code> project, we want to add this to <code>Cargo.toml</code>.</p>
<pre><code class="hljs language-toml"><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">syn</span> = { version = <span class="hljs-string">&quot;2.0&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] }
<span class="hljs-attr">proc-macro2</span> = <span class="hljs-string">&quot;1.0&quot;</span>
<span class="hljs-attr">quote</span> = <span class="hljs-string">&quot;1.0&quot;</span>

<span class="hljs-section">[lib]</span>
<span class="hljs-attr">proc-macro</span> = <span class="hljs-literal">true</span>
</code></pre><p><a href="https://docs.rs/syn/latest/syn/">syn</a>, <a href="https://docs.rs/proc-macro2/latest/proc_macro2/">proc-macro2</a>, and <a href="https://docs.rs/quote/latest/quote/">quote</a> seem to be the essentials for creating a proc macro. We want to replace our primary enum with a new enum, more structs, and some <code>impl</code>s. To do this replacement, we use an attribute macro. To get started using an attribute macro, we write the method as follows.</p>
<pre><code class="hljs language-rs"><span class="hljs-meta">#[proc_macro_attribute]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">message_encoder_decoder</span>(_: TokenStream, input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream {
    <span class="hljs-comment">// draw the rest of the owl</span>
}
</code></pre><p>Now what? For simplicity&#39;s sake, I&#39;ll just be talking about the sending half of this macro. The code for the receiving half is predictably similar. Let&#39;s use syn to create a syntax tree from this token stream. To do that, we can do this.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = parse_macro_input!(input <span class="hljs-keyword">as</span> ItemEnum);
</code></pre><p>Now, let&#39;s start to build the that <code>match</code> statement that we had talked about earlier. To do this, let&#39;s store all the cases and finally construct the <code>match</code> inside of a <code>TryFrom</code>.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cases</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

<span class="hljs-keyword">for</span> <span class="hljs-variable">variant</span> <span class="hljs-keyword">in</span> input.variants {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = variant.ident;
    <span class="hljs-comment">// Skip over the Unknown variant since it&#x27;s a special case</span>
    <span class="hljs-keyword">if</span> name.<span class="hljs-title function_ invoke__">to_string</span>() == <span class="hljs-string">&quot;Unknown&quot;</span> {
        <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-comment">// Get the text contained within our /// comment (i.e. doc = &quot;/// 5 &lt;-&gt;&quot;)</span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">doc</span> = variant.attrs.<span class="hljs-title function_ invoke__">first</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">span</span>().<span class="hljs-title function_ invoke__">source_text</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-comment">// If we don&#x27;t have a -&gt;, we&#x27;re not sending so skip</span>
    <span class="hljs-keyword">if</span> !doc.<span class="hljs-title function_ invoke__">contains</span>(<span class="hljs-string">&quot;-&gt;&quot;</span>) {
        <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-comment">// Get the packet code from the comment </span>
    <span class="hljs-keyword">let</span> <span class="hljs-variable">code</span>: <span class="hljs-type">u8</span> = doc.<span class="hljs-title function_ invoke__">split_whitespace</span>().<span class="hljs-title function_ invoke__">skip</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
}
</code></pre><p>In rust there are three kinds of enum variant fields, <code>Named</code>, <code>Unnamed</code>, and <code>Unit</code>. Named means that the variant contains named fields (i.e. <code>X { a: i32, b: f64 }</code>). Unnamed means that the variant is represented by a tuple (i.e. <code>Y(i32, f64, bool)</code>). <code>Unit</code> means the variant doesn&#39;t store any values (i.e. <code>None</code>). For now, we only have <code>Named</code> fields so let&#39;s deal with that.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">for</span> <span class="hljs-variable">variant</span> <span class="hljs-keyword">in</span> input.variants {
    <span class="hljs-comment">// ...</span>

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Fields</span>::<span class="hljs-title function_ invoke__">Named</span>(field) = variant.fields {
        <span class="hljs-comment">// Store the array of the methods we are calling</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">fns</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

        <span class="hljs-comment">// Iterate over each named field</span>
        <span class="hljs-keyword">for</span> <span class="hljs-variable">field</span> <span class="hljs-keyword">in</span> fields.named {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = field.ident.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Type</span>::<span class="hljs-title function_ invoke__">Path</span>(ty) = &amp;field.ty {
                <span class="hljs-comment">// Remember, we made Writer chainable so we can just join these</span>
                <span class="hljs-keyword">let</span> <span class="hljs-variable">method</span> = <span class="hljs-keyword">match</span> ty.path.segments.<span class="hljs-title function_ invoke__">first</span>().<span class="hljs-title function_ invoke__">unwrap</span>().ident.<span class="hljs-title function_ invoke__">to_string</span>().<span class="hljs-title function_ invoke__">as_str</span>() {
                    <span class="hljs-string">&quot;bool&quot;</span> =&gt; quote! { .<span class="hljs-title function_ invoke__">write_bool</span>(data.#name) },
                    <span class="hljs-string">&quot;u8&quot;</span> =&gt; quote! { .<span class="hljs-title function_ invoke__">write_byte</span>(data.#name) },
                    <span class="hljs-string">&quot;i16&quot;</span> =&gt; quote! { .<span class="hljs-title function_ invoke__">write_i16</span>(data.#name) },
                    ty =&gt; quote! { compile_error!(<span class="hljs-string">&quot;Unknown type: {}&quot;</span>, #ty) },
                }
                <span class="hljs-comment">// Add the method</span>
                fns.<span class="hljs-title function_ invoke__">push</span>(method)
            }
        }

        <span class="hljs-comment">// # embeds the variable and #(#fns)* repeats fns</span>
        cases.<span class="hljs-title function_ invoke__">push</span>(quote! { Message::#<span class="hljs-title function_ invoke__">name</span>(data) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(Writer::<span class="hljs-title function_ invoke__">new</span>(#code)#(#fns)*.<span class="hljs-title function_ invoke__">finalize</span>()) })
    }
}
</code></pre><p>Cool. What is <code>quote!</code> doing, you may ask. It is taking the Rust code and converting it into a token stream. We now have our cases for each server-sent packet. Let&#39;s finally wrap them up in a match statement and get this show on the road. After our for loop, we are going to have this.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-variable">sendable_from</span> = TokenStream::<span class="hljs-title function_ invoke__">from</span>(quote! {
    <span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; TryFrom&lt;Message&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Vec</span>&lt;<span class="hljs-type">u8</span>&gt; {
        <span class="hljs-keyword">type</span> <span class="hljs-title class_">Error</span> = &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>;

        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_from</span>(msg: Message) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>, <span class="hljs-keyword">Self</span>::Error&gt; {
            <span class="hljs-keyword">match</span> msg {
                #(#cases),*, <span class="hljs-comment">// Join each case by a comma</span>
                <span class="hljs-comment">// Our beloved special case</span>
                Message::<span class="hljs-title function_ invoke__">Unknown</span>(code, buf) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(Writer::<span class="hljs-title function_ invoke__">new</span>(code).<span class="hljs-title function_ invoke__">write_bytes</span>(buf).<span class="hljs-title function_ invoke__">finalize</span>()),
                _ =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;Unserializable message. Consider using Message::Unknown&quot;</span>),
            }
        }
    }
});
</code></pre><p>At this point, we are pretty much done. We just have to take our named fields and convert them to unnamed fields with the struct defined somewhere else. The rest of the code is just this.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">structs</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">variants</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

<span class="hljs-keyword">for</span> <span class="hljs-variable">variant</span> <span class="hljs-keyword">in</span> input.variants {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Fields</span>::<span class="hljs-title function_ invoke__">Named</span>(fields) = variant.fields {
        <span class="hljs-keyword">let</span> <span class="hljs-variable">fields</span> = fields.named.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|e| {
            <span class="hljs-keyword">let</span> <span class="hljs-variable">ident</span> = &amp;e.ident;
            <span class="hljs-keyword">let</span> <span class="hljs-variable">ty</span> = &amp;e.ty;
            quote!{ <span class="hljs-keyword">pub</span> #ident: #ty }
        }); <span class="hljs-comment">// get the fields and make them public</span>
        <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = variant.ident; <span class="hljs-comment">// get the name of the variant</span>
        structs.<span class="hljs-title function_ invoke__">push</span>(quote! {
            <span class="hljs-meta">#[derive(Debug, Clone)]</span>
            <span class="hljs-comment">// construct a struct of the same name and fields</span>
            <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> #name {
                #(#fields),*
            }
        });
        variants.<span class="hljs-title function_ invoke__">push</span>(quote! { #<span class="hljs-title function_ invoke__">name</span>(#name) }) <span class="hljs-comment">// the new variant</span>
    } <span class="hljs-keyword">else</span> {
        variants.<span class="hljs-title function_ invoke__">push</span>(quote! { #variant }) <span class="hljs-comment">// nothing changes if it&#x27;s not named</span>
    }
}

TokenStream::<span class="hljs-title function_ invoke__">from</span>(quote! {
    #(#structs)* <span class="hljs-comment">// iterate over all our structs</span>
    <span class="hljs-meta">#[derive(Debug, Clone)]</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; {
        #(#variants),* <span class="hljs-comment">// include all our variants</span>
    }
    #sendable_from <span class="hljs-comment">// include our impl TryFrom</span>
})
</code></pre><p>There is, of course, much more to this. There are more types besides u8, i16, and bool. There&#39;s also more code for handling the client-sent readable packets. All of that is pretty much just doing what we did here but slightly differently. If you are interested in the full code for the <a href="https://github.com/xDimGG/trust/blob/main/macros/src/lib.rs">macro</a>, the <a href="https://github.com/xDimGG/trust/blob/main/src/binary/reader.rs">reader</a>, and the <a href="https://github.com/xDimGG/trust/blob/main/src/binary/writer.rs">writer</a>, it&#39;s all in the <a href="https://github.com/xDimGG/trust">repository</a>.</p>
<h2>Closing Notes</h2>
<p>Macro code can be hard to understand. I created this macro two years ago, and when I came back to it, I couldn&#39;t believe that I wrote it. The whole thing just seemed like gibberish. As a matter of fact, I had no intention to even touch the macro! However, when I tried compiling this project that I haven&#39;t touched in two years with a modern version of Rust, I received the following error.</p>
<pre><code>error[E0512]: cannot transmute between types of different sizes, or dependently-sized types
   --&gt; C:\Users\Dim\.cargo\registry\src\index.crates.io-6f17d22bba15001f\socket2-0.3.12\src\sockaddr.rs:176:9
    |
176 |         mem::transmute::&lt;SocketAddrV4, sockaddr_in&gt;(v4);
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: source type: `SocketAddrV4` (48 bits)
    = note: target type: `SOCKADDR_IN` (128 bits)

For more information about this error, try `rustc --explain E0512`.
</code></pre><p>After a Google search, <a href="https://users.rust-lang.org/t/error-compiling-old-rust-project/83840">this error</a> meant that one of my dependencies is outdated. That dependency turned out to be syn. I was on v1 and needed v2. I upgraded syn to v2, only to find out that the API has slightly changed so some lines were erroring. Because of that, I more or less had to re-understand my entire macro code again, which I really didn&#39;t want to do. Anyway, I did that and fixed it.</p>
<p>However, this got me to thinking. Is there a way I could have made this code more readable? Well, not really. I think proc macros are generally quite hard to read without comments. I could and should probably add a bunch of comments to the code so that when future me has to re-visit this, he&#39;ll at least have a clue of what&#39;s going on... nahhh. Comments are for chumps.</p>
<p>Anyway, that&#39;s all for now. Until we meet again in <a href="/blog/trust-3">part 3</a>.</p>
<!-- HTML_TAG_END --></div></div> 
			
			<script>
				{
					__sveltekit_ig9th2 = {
						base: new URL("../..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [null,{"type":"data","data":{id:"trust-2",content:"{\n\t\"title\": \"Writing Sweet Rust Macros (trust pt. 2)\",\n\t\"date\": 1707829348111,\n\t\"tags\": [\"trust\", \"rust\", \"macros\"]\n}\n---\n\nThere is something I haven't told you yet about trust in [part 1](/blog/trust-1). It is actually a project that I had thought of 2 years ago. Back then, I wanted to do the same thing as what I'm doing now, but I quit once I realized the actual scale of this project. As it turns out, this isn't an easy project. At the beginning, I found it strange that the Terraria server is just a headless client (meaning the server treats itself as an \"invisible\" player in the server). After really thinking about it, it makes plenty of sense. All of the game logic (mob spawning, water flowing, entity interactions) have to be fired off by some central authority — the server — and this means we need Terraria's logic, spawn rates, etc. all in our code. This is definitely a lot to implement and what halted my progress the first time. To put it short, I felt like I was about to open Pandora's box. I didn't like that feeling of uncertainty and rather than even begin to start, I gave up then and there. Alas, we are back and my mentality has greatly shifted since then.\n\n> The struggle itself towards the heights is enough to fill a man's heart. One must imagine Sisyphus happy.\n\n## Why a Macro?\n\nOk, so we have a fairly structured network protocol at this point. Each packet is structured like so.\n\n| field | type | length |\n| - | - | - |\n| len | u16 | 2 |\n| code | u8 | 1 |\n| msg | bytes | len-3 |\n\nDepending on `code`, `msg` may contain certain fields. For instance, if `code` is 3, we have a connection approval message whose fields are contained in `msg` like so.\n\n| field | type | length |\n| - | - | - |\n| id | u8 | 1 |\n| flag | bool | 1 |\n\n`id` represents the ID that the server assigns the user and `flag` seems to represent a flag called `ServerWantsToRunCheckBytesInClientLoopThread`. If this is true, the client calls `NetMessage.CheckBytes()` inside `Main.InnerClientLoop()`. Don't ask me... all I know is that this is hardcoded to be `false` every time.\n\nLet's take another example. If `code` is 5 and client-sent, the client is updating the server about a particular slot in their inventory. If `code` is 5 and broadcasted by the server, the server is notifying all players of a change in a player's inventory. *Note: internally, an inventory represents all a players items including their armor, dyes, pets, mounts, etc. Not just the items in the top left of their escape menu.*\n\n| field | type | length |\n| - | - | - |\n| id | u8 | 1 |\n| slot_id | i16 | 2 |\n| amount | i16 | 2 |\n| prefix | u8 | 1 |\n| item_id | i16 | 2 |\n\nYou get the gist? Anyway, my goal was to be able to write a Rust enum representing each packet so we can use `match`. I also want it to be aware of the code of each packet to automatically parse and encode it. In the doc comment, I put the packet's code. Also, let's not create the read method for server-only packets and write for client-only packets. In the doc comment, `->` means send-only, `\u003C-` means receive-only, and `\u003C->` means bidirectional. That would mean our macro should be able to convert this.\n\n```rs\n#[our_cool_proc_macro]\npub enum Message\u003C'a> {\n\t/// 3 ->\n\tConnectionApprove {\n\t\tclient_id: u8,\n\t\tflag: bool,\n\t},\n\t/// 5 \u003C->\n\tPlayerInventorySlot {\n\t\tclient_id: u8,\n\t\tslot_id: i16,\n\t\tamount: i16,\n\t\tprefix: u8,\n\t\titem_id: i16,\n\t},\n}\n```\n\ninto this\n\n```rs\npub struct ConnectionApprove {\n\tpub client_id: u8,\n\tpub flag: bool,\n}\n\npub struct PlayerInventorySlot {\n\tpub client_id: u8,\n\tpub slot_id: i16,\n\tpub amount: i16,\n\tpub prefix: u8,\n\tpub item_id: i16,\n}\n\n#[our_cool_proc_macro]\npub enum Message\u003C'a> {\n\tConnectionApprove(ConnectionApprove),\n\tPlayerInventorySlot(PlayerInventorySlot),\n\tUnknown(u8, &'a [u8]),\n}\n\n// let's assume the caller has already read the length of the packet and\n// is giving us everything after the length\nfn buffer_to_message(buf: &[u8]) -> Message {\n\tlet r = Reader::new(buf); // create a byte reader\n\tlet code = r.read_byte();\n\tmatch code {\n\t\t5 => Message::PlayerInventorySlot(PlayerInventorySlot {\n\t\t\tclient_id: r.read_byte(),\n\t\t\tslot_id: r.read_i16(),\n\t\t\tamount: r.read_i16(),\n\t\t\tprefix: r.read_byte(),\n\t\t\titem_id: r.read_i16(),\n\t\t}),\n\t\t_ => Message::Unknown(code, &buf[1..])\n\t}\n}\n\nfn message_to_buffer(msg: Message) -> &[u8] {\n\tmatch Message {\n\t\tMessage::ConnectionApprove(ca) => {\n\t\t\tlet w = Writer::new(3);\n\t\t\tw.write_byte(client_id);\n\t\t\tw.write_bool(flag);\n\t\t\tw.finalize() // sets the first two bytes as the length and returns byte array\n\t\t}\n\t\tMessage::PlayerInventorySlot(slot) => {\n\t\t\tlet w = Writer::new(5);\n\t\t\tw.write_byte(slot.client_id);\n\t\t\tw.write_i16(slot.slot_id);\n\t\t\tw.write_i16(slot.amount);\n\t\t\tw.write_byte(slot.prefix);\n\t\t\tw.write_i16(slot.item_id);\n\t\t\tw.finalize()\n\t\t}\n\t\t_ => Message::Unknown(code, &buf[1..])\n\t}\n}\n```\n\nIn case you're wondering why I don't want to write the structs outside of the enum myself, it's because if I do, then this macro will be much more complicated as it won't just be completely contained within one enum.\n\n## Binary Reader and Writer\n\nFor starters, let's implement our `Reader` and `Writer`. Our reader will look like this,\n\n```rs\nimpl\u003C'a> Reader\u003C'a> {\n\tpub fn new(buf: &'a [u8]) -> Self {\n\t\tSelf { buf, cur: 0 }\n\t}\n\n\tpub fn read_bytes(&mut self, amount: usize) -> &[u8] {\n\t\tself.cur += amount;\n\t\t&self.buf[(self.cur - amount)..self.cur]\n\t}\n\n\tpub fn read_byte(&mut self, amount: usize) -> u8 {\n\t\tself.read_bytes(1)[0]\n\t}\n\n\tpub fn read_i16(&mut self) -> i16 {\n\t\ti16::from_le_bytes(self.read_bytes(2).try_into().unwrap())\n\t}\n\n\t// add methods as needed\n}\n```\n\nand our writer will look like this,\n\n```rs\nimpl Writer {\n\tpub fn new(code: u8) -> Self {\n\t\tSelf { buf: vec![0, 0, code] } // start the buffer with two empty bytes and the message code\n\t}\n\n\t// method to be called when a packet is done being constructed\n\tpub fn finalize(mut self) -> Vec\u003Cu8> {\n\t\tlet [a, b] = (self.buf.len() as u16).to_le_bytes(); // convert the length of the buffer to 2 bytes\n\t\tself.buf[0] = a; // replace the first two bytes with the length of the array\n\t\tself.buf[1] = b;\n\t\tself.buf\n\t}\n\n\tpub fn write_bytes(mut self, bytes: &[u8]) -> Self {\n\t\tself.buf.append(&mut bytes.to_vec());\n\t\tself\n\t}\n\n\tpub fn write_byte(mut self, byte: u8) -> Self {\n\t\tself.buf.push(byte);\n\t\tself\n\t}\n\n\tpub fn write_i16(self, num: i16) -> Self {\n\t\tself.write_bytes(&num.to_le_bytes())\n\t}\n\n\t// add methods as needed\n}\n```\n\nMakes sense? I'm just trying to get through this quickly since this is mostly boilerplate for the real difficulty which is writing a procedural macro.\n\nAs per The Rust Reference,\n> Procedural macros allow you to run code at compile time that operates over Rust syntax, both consuming and producing Rust syntax. You can sort of think of procedural macros as functions from an AST to another AST.\n\n## Set Up a Project for the Macro\n\nSo, we want to parse the AST and generate our own AST. Let's create a new cargo project called macros (`cargo init macros --lib`) and include in our main project (which actually hasn't been established yet) by adding `macros = { path = \"macros\" }` to `Cargo.toml`. In the `macros` project, we want to add this to `Cargo.toml`.\n\n```toml\n[dependencies]\nsyn = { version = \"2.0\", features = [\"full\"] }\nproc-macro2 = \"1.0\"\nquote = \"1.0\"\n\n[lib]\nproc-macro = true\n```\n\n[syn](https://docs.rs/syn/latest/syn/), [proc-macro2](https://docs.rs/proc-macro2/latest/proc_macro2/), and [quote](https://docs.rs/quote/latest/quote/) seem to be the essentials for creating a proc macro. We want to replace our primary enum with a new enum, more structs, and some `impl`s. To do this replacement, we use an attribute macro. To get started using an attribute macro, we write the method as follows.\n\n```rs\n#[proc_macro_attribute]\npub fn message_encoder_decoder(_: TokenStream, input: TokenStream) -> TokenStream {\n\t// draw the rest of the owl\n}\n```\n\nNow what? For simplicity's sake, I'll just be talking about the sending half of this macro. The code for the receiving half is predictably similar. Let's use syn to create a syntax tree from this token stream. To do that, we can do this.\n\n```rs\nlet input = parse_macro_input!(input as ItemEnum);\n```\n\nNow, let's start to build the that `match` statement that we had talked about earlier. To do this, let's store all the cases and finally construct the `match` inside of a `TryFrom`.\n\n```rs\nlet mut cases = Vec::new();\n\nfor variant in input.variants {\n\tlet name = variant.ident;\n\t// Skip over the Unknown variant since it's a special case\n\tif name.to_string() == \"Unknown\" {\n\t\tcontinue;\n\t}\n\n\t// Get the text contained within our /// comment (i.e. doc = \"/// 5 \u003C->\")\n\tlet doc = variant.attrs.first().unwrap().span().source_text().unwrap();\n\t// If we don't have a ->, we're not sending so skip\n\tif !doc.contains(\"->\") {\n\t\tcontinue;\n\t}\n\n\t// Get the packet code from the comment \n\tlet code: u8 = doc.split_whitespace().skip(1).next().unwrap().parse().unwrap();\n}\n```\n\nIn rust there are three kinds of enum variant fields, `Named`, `Unnamed`, and `Unit`. Named means that the variant contains named fields (i.e. `X { a: i32, b: f64 }`). Unnamed means that the variant is represented by a tuple (i.e. `Y(i32, f64, bool)`). `Unit` means the variant doesn't store any values (i.e. `None`). For now, we only have `Named` fields so let's deal with that.\n\n```rs\nfor variant in input.variants {\n\t// ...\n\n\tif let Fields::Named(field) = variant.fields {\n\t\t// Store the array of the methods we are calling\n\t\tlet mut fns = Vec::new();\n\n\t\t// Iterate over each named field\n\t\tfor field in fields.named {\n\t\t\tlet name = field.ident.as_ref().unwrap();\n\t\t\tif let Type::Path(ty) = &field.ty {\n\t\t\t\t// Remember, we made Writer chainable so we can just join these\n\t\t\t\tlet method = match ty.path.segments.first().unwrap().ident.to_string().as_str() {\n\t\t\t\t\t\"bool\" => quote! { .write_bool(data.#name) },\n\t\t\t\t\t\"u8\" => quote! { .write_byte(data.#name) },\n\t\t\t\t\t\"i16\" => quote! { .write_i16(data.#name) },\n\t\t\t\t\tty => quote! { compile_error!(\"Unknown type: {}\", #ty) },\n\t\t\t\t}\n\t\t\t\t// Add the method\n\t\t\t\tfns.push(method)\n\t\t\t}\n\t\t}\n\n\t\t// # embeds the variable and #(#fns)* repeats fns\n\t\tcases.push(quote! { Message::#name(data) => Ok(Writer::new(#code)#(#fns)*.finalize()) })\n\t}\n}\n```\n\nCool. What is `quote!` doing, you may ask. It is taking the Rust code and converting it into a token stream. We now have our cases for each server-sent packet. Let's finally wrap them up in a match statement and get this show on the road. After our for loop, we are going to have this.\n\n\n```rs\nlet sendable_from = TokenStream::from(quote! {\n\timpl\u003C'a> TryFrom\u003CMessage\u003C'a>> for Vec\u003Cu8> {\n\t\ttype Error = &'static str;\n\n\t\tfn try_from(msg: Message) -> Result\u003CSelf, Self::Error> {\n\t\t\tmatch msg {\n\t\t\t\t#(#cases),*, // Join each case by a comma\n\t\t\t\t// Our beloved special case\n\t\t\t\tMessage::Unknown(code, buf) => Ok(Writer::new(code).write_bytes(buf).finalize()),\n\t\t\t\t_ => Err(\"Unserializable message. Consider using Message::Unknown\"),\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\nAt this point, we are pretty much done. We just have to take our named fields and convert them to unnamed fields with the struct defined somewhere else. The rest of the code is just this.\n\n```rs\nlet mut structs = Vec::new();\nlet mut variants = Vec::new();\n\nfor variant in input.variants {\n\tif let Fields::Named(fields) = variant.fields {\n\t\tlet fields = fields.named.iter().map(|e| {\n\t\t\tlet ident = &e.ident;\n\t\t\tlet ty = &e.ty;\n\t\t\tquote!{ pub #ident: #ty }\n\t\t}); // get the fields and make them public\n\t\tlet name = variant.ident; // get the name of the variant\n\t\tstructs.push(quote! {\n\t\t\t#[derive(Debug, Clone)]\n\t\t\t// construct a struct of the same name and fields\n\t\t\tpub struct #name {\n\t\t\t\t#(#fields),*\n\t\t\t}\n\t\t});\n\t\tvariants.push(quote! { #name(#name) }) // the new variant\n\t} else {\n\t\tvariants.push(quote! { #variant }) // nothing changes if it's not named\n\t}\n}\n\nTokenStream::from(quote! {\n\t#(#structs)* // iterate over all our structs\n\t#[derive(Debug, Clone)]\n\tpub enum Message\u003C'a> {\n\t\t#(#variants),* // include all our variants\n\t}\n\t#sendable_from // include our impl TryFrom\n})\n```\n\nThere is, of course, much more to this. There are more types besides u8, i16, and bool. There's also more code for handling the client-sent readable packets. All of that is pretty much just doing what we did here but slightly differently. If you are interested in the full code for the [macro](https://github.com/xDimGG/trust/blob/main/macros/src/lib.rs), the [reader](https://github.com/xDimGG/trust/blob/main/src/binary/reader.rs), and the [writer](https://github.com/xDimGG/trust/blob/main/src/binary/writer.rs), it's all in the [repository](https://github.com/xDimGG/trust).\n\n## Closing Notes\nMacro code can be hard to understand. I created this macro two years ago, and when I came back to it, I couldn't believe that I wrote it. The whole thing just seemed like gibberish. As a matter of fact, I had no intention to even touch the macro! However, when I tried compiling this project that I haven't touched in two years with a modern version of Rust, I received the following error.\n\n```\nerror[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n   --> C:\\Users\\Dim\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\socket2-0.3.12\\src\\sockaddr.rs:176:9\n    |\n176 |         mem::transmute::\u003CSocketAddrV4, sockaddr_in>(v4);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: source type: `SocketAddrV4` (48 bits)\n    = note: target type: `SOCKADDR_IN` (128 bits)\n\nFor more information about this error, try `rustc --explain E0512`.\n```\n\nAfter a Google search, [this error](https://users.rust-lang.org/t/error-compiling-old-rust-project/83840) meant that one of my dependencies is outdated. That dependency turned out to be syn. I was on v1 and needed v2. I upgraded syn to v2, only to find out that the API has slightly changed so some lines were erroring. Because of that, I more or less had to re-understand my entire macro code again, which I really didn't want to do. Anyway, I did that and fixed it.\n\nHowever, this got me to thinking. Is there a way I could have made this code more readable? Well, not really. I think proc macros are generally quite hard to read without comments. I could and should probably add a bunch of comments to the code so that when future me has to re-visit this, he'll at least have a clue of what's going on... nahhh. Comments are for chumps.\n\nAnyway, that's all for now. Until we meet again in [part 3](/blog/trust-3).\n",html:"\u003Cp>There is something I haven&#39;t told you yet about trust in \u003Ca href=\"/blog/trust-1\">part 1\u003C/a>. It is actually a project that I had thought of 2 years ago. Back then, I wanted to do the same thing as what I&#39;m doing now, but I quit once I realized the actual scale of this project. As it turns out, this isn&#39;t an easy project. At the beginning, I found it strange that the Terraria server is just a headless client (meaning the server treats itself as an &quot;invisible&quot; player in the server). After really thinking about it, it makes plenty of sense. All of the game logic (mob spawning, water flowing, entity interactions) have to be fired off by some central authority — the server — and this means we need Terraria&#39;s logic, spawn rates, etc. all in our code. This is definitely a lot to implement and what halted my progress the first time. To put it short, I felt like I was about to open Pandora&#39;s box. I didn&#39;t like that feeling of uncertainty and rather than even begin to start, I gave up then and there. Alas, we are back and my mentality has greatly shifted since then.\u003C/p>\n\u003Cblockquote>\n\u003Cp>The struggle itself towards the heights is enough to fill a man&#39;s heart. One must imagine Sisyphus happy.\u003C/p>\n\u003C/blockquote>\n\u003Ch2>Why a Macro?\u003C/h2>\n\u003Cp>Ok, so we have a fairly structured network protocol at this point. Each packet is structured like so.\u003C/p>\n\u003Ctable>\n\u003Cthead>\n\u003Ctr>\n\u003Cth>field\u003C/th>\n\u003Cth>type\u003C/th>\n\u003Cth>length\u003C/th>\n\u003C/tr>\n\u003C/thead>\n\u003Ctbody>\u003Ctr>\n\u003Ctd>len\u003C/td>\n\u003Ctd>u16\u003C/td>\n\u003Ctd>2\u003C/td>\n\u003C/tr>\n\u003Ctr>\n\u003Ctd>code\u003C/td>\n\u003Ctd>u8\u003C/td>\n\u003Ctd>1\u003C/td>\n\u003C/tr>\n\u003Ctr>\n\u003Ctd>msg\u003C/td>\n\u003Ctd>bytes\u003C/td>\n\u003Ctd>len-3\u003C/td>\n\u003C/tr>\n\u003C/tbody>\u003C/table>\n\u003Cp>Depending on \u003Ccode>code\u003C/code>, \u003Ccode>msg\u003C/code> may contain certain fields. For instance, if \u003Ccode>code\u003C/code> is 3, we have a connection approval message whose fields are contained in \u003Ccode>msg\u003C/code> like so.\u003C/p>\n\u003Ctable>\n\u003Cthead>\n\u003Ctr>\n\u003Cth>field\u003C/th>\n\u003Cth>type\u003C/th>\n\u003Cth>length\u003C/th>\n\u003C/tr>\n\u003C/thead>\n\u003Ctbody>\u003Ctr>\n\u003Ctd>id\u003C/td>\n\u003Ctd>u8\u003C/td>\n\u003Ctd>1\u003C/td>\n\u003C/tr>\n\u003Ctr>\n\u003Ctd>flag\u003C/td>\n\u003Ctd>bool\u003C/td>\n\u003Ctd>1\u003C/td>\n\u003C/tr>\n\u003C/tbody>\u003C/table>\n\u003Cp>\u003Ccode>id\u003C/code> represents the ID that the server assigns the user and \u003Ccode>flag\u003C/code> seems to represent a flag called \u003Ccode>ServerWantsToRunCheckBytesInClientLoopThread\u003C/code>. If this is true, the client calls \u003Ccode>NetMessage.CheckBytes()\u003C/code> inside \u003Ccode>Main.InnerClientLoop()\u003C/code>. Don&#39;t ask me... all I know is that this is hardcoded to be \u003Ccode>false\u003C/code> every time.\u003C/p>\n\u003Cp>Let&#39;s take another example. If \u003Ccode>code\u003C/code> is 5 and client-sent, the client is updating the server about a particular slot in their inventory. If \u003Ccode>code\u003C/code> is 5 and broadcasted by the server, the server is notifying all players of a change in a player&#39;s inventory. \u003Cem>Note: internally, an inventory represents all a players items including their armor, dyes, pets, mounts, etc. Not just the items in the top left of their escape menu.\u003C/em>\u003C/p>\n\u003Ctable>\n\u003Cthead>\n\u003Ctr>\n\u003Cth>field\u003C/th>\n\u003Cth>type\u003C/th>\n\u003Cth>length\u003C/th>\n\u003C/tr>\n\u003C/thead>\n\u003Ctbody>\u003Ctr>\n\u003Ctd>id\u003C/td>\n\u003Ctd>u8\u003C/td>\n\u003Ctd>1\u003C/td>\n\u003C/tr>\n\u003Ctr>\n\u003Ctd>slot_id\u003C/td>\n\u003Ctd>i16\u003C/td>\n\u003Ctd>2\u003C/td>\n\u003C/tr>\n\u003Ctr>\n\u003Ctd>amount\u003C/td>\n\u003Ctd>i16\u003C/td>\n\u003Ctd>2\u003C/td>\n\u003C/tr>\n\u003Ctr>\n\u003Ctd>prefix\u003C/td>\n\u003Ctd>u8\u003C/td>\n\u003Ctd>1\u003C/td>\n\u003C/tr>\n\u003Ctr>\n\u003Ctd>item_id\u003C/td>\n\u003Ctd>i16\u003C/td>\n\u003Ctd>2\u003C/td>\n\u003C/tr>\n\u003C/tbody>\u003C/table>\n\u003Cp>You get the gist? Anyway, my goal was to be able to write a Rust enum representing each packet so we can use \u003Ccode>match\u003C/code>. I also want it to be aware of the code of each packet to automatically parse and encode it. In the doc comment, I put the packet&#39;s code. Also, let&#39;s not create the read method for server-only packets and write for client-only packets. In the doc comment, \u003Ccode>-&gt;\u003C/code> means send-only, \u003Ccode>&lt;-\u003C/code> means receive-only, and \u003Ccode>&lt;-&gt;\u003C/code> means bidirectional. That would mean our macro should be able to convert this.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-meta\">#[our_cool_proc_macro]\u003C/span>\n\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">enum\u003C/span> \u003Cspan class=\"hljs-title class_\">Message\u003C/span>&lt;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span>&gt; {\n    \u003Cspan class=\"hljs-comment\">/// 3 -&gt;\u003C/span>\n    ConnectionApprove {\n        client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n        flag: \u003Cspan class=\"hljs-type\">bool\u003C/span>,\n    },\n    \u003Cspan class=\"hljs-comment\">/// 5 &lt;-&gt;\u003C/span>\n    PlayerInventorySlot {\n        client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n        slot_id: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n        amount: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n        prefix: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n        item_id: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n    },\n}\n\u003C/code>\u003C/pre>\u003Cp>into this\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">ConnectionApprove\u003C/span> {\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> flag: \u003Cspan class=\"hljs-type\">bool\u003C/span>,\n}\n\n\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">struct\u003C/span> \u003Cspan class=\"hljs-title class_\">PlayerInventorySlot\u003C/span> {\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> client_id: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> slot_id: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> amount: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> prefix: \u003Cspan class=\"hljs-type\">u8\u003C/span>,\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> item_id: \u003Cspan class=\"hljs-type\">i16\u003C/span>,\n}\n\n\u003Cspan class=\"hljs-meta\">#[our_cool_proc_macro]\u003C/span>\n\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">enum\u003C/span> \u003Cspan class=\"hljs-title class_\">Message\u003C/span>&lt;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span>&gt; {\n    \u003Cspan class=\"hljs-title function_ invoke__\">ConnectionApprove\u003C/span>(ConnectionApprove),\n    \u003Cspan class=\"hljs-title function_ invoke__\">PlayerInventorySlot\u003C/span>(PlayerInventorySlot),\n    \u003Cspan class=\"hljs-title function_ invoke__\">Unknown\u003C/span>(\u003Cspan class=\"hljs-type\">u8\u003C/span>, &amp;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span> [\u003Cspan class=\"hljs-type\">u8\u003C/span>]),\n}\n\n\u003Cspan class=\"hljs-comment\">// let&#x27;s assume the caller has already read the length of the packet and\u003C/span>\n\u003Cspan class=\"hljs-comment\">// is giving us everything after the length\u003C/span>\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">buffer_to_message\u003C/span>(buf: &amp;[\u003Cspan class=\"hljs-type\">u8\u003C/span>]) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> Message {\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">r\u003C/span> = Reader::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(buf); \u003Cspan class=\"hljs-comment\">// create a byte reader\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">code\u003C/span> = r.\u003Cspan class=\"hljs-title function_ invoke__\">read_byte\u003C/span>();\n    \u003Cspan class=\"hljs-keyword\">match\u003C/span> code {\n        \u003Cspan class=\"hljs-number\">5\u003C/span> =&gt; Message::\u003Cspan class=\"hljs-title function_ invoke__\">PlayerInventorySlot\u003C/span>(PlayerInventorySlot {\n            client_id: r.\u003Cspan class=\"hljs-title function_ invoke__\">read_byte\u003C/span>(),\n            slot_id: r.\u003Cspan class=\"hljs-title function_ invoke__\">read_i16\u003C/span>(),\n            amount: r.\u003Cspan class=\"hljs-title function_ invoke__\">read_i16\u003C/span>(),\n            prefix: r.\u003Cspan class=\"hljs-title function_ invoke__\">read_byte\u003C/span>(),\n            item_id: r.\u003Cspan class=\"hljs-title function_ invoke__\">read_i16\u003C/span>(),\n        }),\n        _ =&gt; Message::\u003Cspan class=\"hljs-title function_ invoke__\">Unknown\u003C/span>(code, &amp;buf[\u003Cspan class=\"hljs-number\">1\u003C/span>..])\n    }\n}\n\n\u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">message_to_buffer\u003C/span>(msg: Message) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> &amp;[\u003Cspan class=\"hljs-type\">u8\u003C/span>] {\n    \u003Cspan class=\"hljs-keyword\">match\u003C/span> Message {\n        Message::\u003Cspan class=\"hljs-title function_ invoke__\">ConnectionApprove\u003C/span>(ca) =&gt; {\n            \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">w\u003C/span> = Writer::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(\u003Cspan class=\"hljs-number\">3\u003C/span>);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">write_byte\u003C/span>(client_id);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">write_bool\u003C/span>(flag);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">finalize\u003C/span>() \u003Cspan class=\"hljs-comment\">// sets the first two bytes as the length and returns byte array\u003C/span>\n        }\n        Message::\u003Cspan class=\"hljs-title function_ invoke__\">PlayerInventorySlot\u003C/span>(slot) =&gt; {\n            \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">w\u003C/span> = Writer::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(\u003Cspan class=\"hljs-number\">5\u003C/span>);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">write_byte\u003C/span>(slot.client_id);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">write_i16\u003C/span>(slot.slot_id);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">write_i16\u003C/span>(slot.amount);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">write_byte\u003C/span>(slot.prefix);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">write_i16\u003C/span>(slot.item_id);\n            w.\u003Cspan class=\"hljs-title function_ invoke__\">finalize\u003C/span>()\n        }\n        _ =&gt; Message::\u003Cspan class=\"hljs-title function_ invoke__\">Unknown\u003C/span>(code, &amp;buf[\u003Cspan class=\"hljs-number\">1\u003C/span>..])\n    }\n}\n\u003C/code>\u003C/pre>\u003Cp>In case you&#39;re wondering why I don&#39;t want to write the structs outside of the enum myself, it&#39;s because if I do, then this macro will be much more complicated as it won&#39;t just be completely contained within one enum.\u003C/p>\n\u003Ch2>Binary Reader and Writer\u003C/h2>\n\u003Cp>For starters, let&#39;s implement our \u003Ccode>Reader\u003C/code> and \u003Ccode>Writer\u003C/code>. Our reader will look like this,\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">impl\u003C/span>&lt;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span>&gt; Reader&lt;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span>&gt; {\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">new\u003C/span>(buf: &amp;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span> [\u003Cspan class=\"hljs-type\">u8\u003C/span>]) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-keyword\">Self\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">Self\u003C/span> { buf, cur: \u003Cspan class=\"hljs-number\">0\u003C/span> }\n    }\n\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">read_bytes\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>, amount: \u003Cspan class=\"hljs-type\">usize\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> &amp;[\u003Cspan class=\"hljs-type\">u8\u003C/span>] {\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.cur += amount;\n        &amp;\u003Cspan class=\"hljs-keyword\">self\u003C/span>.buf[(\u003Cspan class=\"hljs-keyword\">self\u003C/span>.cur - amount)..\u003Cspan class=\"hljs-keyword\">self\u003C/span>.cur]\n    }\n\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">read_byte\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>, amount: \u003Cspan class=\"hljs-type\">usize\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">u8\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">read_bytes\u003C/span>(\u003Cspan class=\"hljs-number\">1\u003C/span>)[\u003Cspan class=\"hljs-number\">0\u003C/span>]\n    }\n\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">read_i16\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">i16\u003C/span> {\n        \u003Cspan class=\"hljs-type\">i16\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">from_le_bytes\u003C/span>(\u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">read_bytes\u003C/span>(\u003Cspan class=\"hljs-number\">2\u003C/span>).\u003Cspan class=\"hljs-title function_ invoke__\">try_into\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">unwrap\u003C/span>())\n    }\n\n    \u003Cspan class=\"hljs-comment\">// add methods as needed\u003C/span>\n}\n\u003C/code>\u003C/pre>\u003Cp>and our writer will look like this,\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">impl\u003C/span> \u003Cspan class=\"hljs-title class_\">Writer\u003C/span> {\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">new\u003C/span>(code: \u003Cspan class=\"hljs-type\">u8\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-keyword\">Self\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">Self\u003C/span> { buf: \u003Cspan class=\"hljs-built_in\">vec!\u003C/span>[\u003Cspan class=\"hljs-number\">0\u003C/span>, \u003Cspan class=\"hljs-number\">0\u003C/span>, code] } \u003Cspan class=\"hljs-comment\">// start the buffer with two empty bytes and the message code\u003C/span>\n    }\n\n    \u003Cspan class=\"hljs-comment\">// method to be called when a packet is done being constructed\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">finalize\u003C/span>(\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">Vec\u003C/span>&lt;\u003Cspan class=\"hljs-type\">u8\u003C/span>&gt; {\n        \u003Cspan class=\"hljs-keyword\">let\u003C/span> [a, b] = (\u003Cspan class=\"hljs-keyword\">self\u003C/span>.buf.\u003Cspan class=\"hljs-title function_ invoke__\">len\u003C/span>() \u003Cspan class=\"hljs-keyword\">as\u003C/span> \u003Cspan class=\"hljs-type\">u16\u003C/span>).\u003Cspan class=\"hljs-title function_ invoke__\">to_le_bytes\u003C/span>(); \u003Cspan class=\"hljs-comment\">// convert the length of the buffer to 2 bytes\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.buf[\u003Cspan class=\"hljs-number\">0\u003C/span>] = a; \u003Cspan class=\"hljs-comment\">// replace the first two bytes with the length of the array\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.buf[\u003Cspan class=\"hljs-number\">1\u003C/span>] = b;\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.buf\n    }\n\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">write_bytes\u003C/span>(\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>, bytes: &amp;[\u003Cspan class=\"hljs-type\">u8\u003C/span>]) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-keyword\">Self\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.buf.\u003Cspan class=\"hljs-title function_ invoke__\">append\u003C/span>(&amp;\u003Cspan class=\"hljs-keyword\">mut\u003C/span> bytes.\u003Cspan class=\"hljs-title function_ invoke__\">to_vec\u003C/span>());\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>\n    }\n\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">write_byte\u003C/span>(\u003Cspan class=\"hljs-keyword\">mut\u003C/span> \u003Cspan class=\"hljs-keyword\">self\u003C/span>, byte: \u003Cspan class=\"hljs-type\">u8\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-keyword\">Self\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.buf.\u003Cspan class=\"hljs-title function_ invoke__\">push\u003C/span>(byte);\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>\n    }\n\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">write_i16\u003C/span>(\u003Cspan class=\"hljs-keyword\">self\u003C/span>, num: \u003Cspan class=\"hljs-type\">i16\u003C/span>) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-keyword\">Self\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">self\u003C/span>.\u003Cspan class=\"hljs-title function_ invoke__\">write_bytes\u003C/span>(&amp;num.\u003Cspan class=\"hljs-title function_ invoke__\">to_le_bytes\u003C/span>())\n    }\n\n    \u003Cspan class=\"hljs-comment\">// add methods as needed\u003C/span>\n}\n\u003C/code>\u003C/pre>\u003Cp>Makes sense? I&#39;m just trying to get through this quickly since this is mostly boilerplate for the real difficulty which is writing a procedural macro.\u003C/p>\n\u003Cp>As per The Rust Reference,\u003C/p>\n\u003Cblockquote>\n\u003Cp>Procedural macros allow you to run code at compile time that operates over Rust syntax, both consuming and producing Rust syntax. You can sort of think of procedural macros as functions from an AST to another AST.\u003C/p>\n\u003C/blockquote>\n\u003Ch2>Set Up a Project for the Macro\u003C/h2>\n\u003Cp>So, we want to parse the AST and generate our own AST. Let&#39;s create a new cargo project called macros (\u003Ccode>cargo init macros --lib\u003C/code>) and include in our main project (which actually hasn&#39;t been established yet) by adding \u003Ccode>macros = { path = &quot;macros&quot; }\u003C/code> to \u003Ccode>Cargo.toml\u003C/code>. In the \u003Ccode>macros\u003C/code> project, we want to add this to \u003Ccode>Cargo.toml\u003C/code>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-toml\">\u003Cspan class=\"hljs-section\">[dependencies]\u003C/span>\n\u003Cspan class=\"hljs-attr\">syn\u003C/span> = { version = \u003Cspan class=\"hljs-string\">&quot;2.0&quot;\u003C/span>, features = [\u003Cspan class=\"hljs-string\">&quot;full&quot;\u003C/span>] }\n\u003Cspan class=\"hljs-attr\">proc-macro2\u003C/span> = \u003Cspan class=\"hljs-string\">&quot;1.0&quot;\u003C/span>\n\u003Cspan class=\"hljs-attr\">quote\u003C/span> = \u003Cspan class=\"hljs-string\">&quot;1.0&quot;\u003C/span>\n\n\u003Cspan class=\"hljs-section\">[lib]\u003C/span>\n\u003Cspan class=\"hljs-attr\">proc-macro\u003C/span> = \u003Cspan class=\"hljs-literal\">true\u003C/span>\n\u003C/code>\u003C/pre>\u003Cp>\u003Ca href=\"https://docs.rs/syn/latest/syn/\">syn\u003C/a>, \u003Ca href=\"https://docs.rs/proc-macro2/latest/proc_macro2/\">proc-macro2\u003C/a>, and \u003Ca href=\"https://docs.rs/quote/latest/quote/\">quote\u003C/a> seem to be the essentials for creating a proc macro. We want to replace our primary enum with a new enum, more structs, and some \u003Ccode>impl\u003C/code>s. To do this replacement, we use an attribute macro. To get started using an attribute macro, we write the method as follows.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-meta\">#[proc_macro_attribute]\u003C/span>\n\u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">message_encoder_decoder\u003C/span>(_: TokenStream, input: TokenStream) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> TokenStream {\n    \u003Cspan class=\"hljs-comment\">// draw the rest of the owl\u003C/span>\n}\n\u003C/code>\u003C/pre>\u003Cp>Now what? For simplicity&#39;s sake, I&#39;ll just be talking about the sending half of this macro. The code for the receiving half is predictably similar. Let&#39;s use syn to create a syntax tree from this token stream. To do that, we can do this.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">input\u003C/span> = parse_macro_input!(input \u003Cspan class=\"hljs-keyword\">as\u003C/span> ItemEnum);\n\u003C/code>\u003C/pre>\u003Cp>Now, let&#39;s start to build the that \u003Ccode>match\u003C/code> statement that we had talked about earlier. To do this, let&#39;s store all the cases and finally construct the \u003Ccode>match\u003C/code> inside of a \u003Ccode>TryFrom\u003C/code>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">cases\u003C/span> = \u003Cspan class=\"hljs-type\">Vec\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>();\n\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-variable\">variant\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> input.variants {\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">name\u003C/span> = variant.ident;\n    \u003Cspan class=\"hljs-comment\">// Skip over the Unknown variant since it&#x27;s a special case\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> name.\u003Cspan class=\"hljs-title function_ invoke__\">to_string\u003C/span>() == \u003Cspan class=\"hljs-string\">&quot;Unknown&quot;\u003C/span> {\n        \u003Cspan class=\"hljs-keyword\">continue\u003C/span>;\n    }\n\n    \u003Cspan class=\"hljs-comment\">// Get the text contained within our /// comment (i.e. doc = &quot;/// 5 &lt;-&gt;&quot;)\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">doc\u003C/span> = variant.attrs.\u003Cspan class=\"hljs-title function_ invoke__\">first\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">unwrap\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">span\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">source_text\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">unwrap\u003C/span>();\n    \u003Cspan class=\"hljs-comment\">// If we don&#x27;t have a -&gt;, we&#x27;re not sending so skip\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> !doc.\u003Cspan class=\"hljs-title function_ invoke__\">contains\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;-&gt;&quot;\u003C/span>) {\n        \u003Cspan class=\"hljs-keyword\">continue\u003C/span>;\n    }\n\n    \u003Cspan class=\"hljs-comment\">// Get the packet code from the comment \u003C/span>\n    \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">code\u003C/span>: \u003Cspan class=\"hljs-type\">u8\u003C/span> = doc.\u003Cspan class=\"hljs-title function_ invoke__\">split_whitespace\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">skip\u003C/span>(\u003Cspan class=\"hljs-number\">1\u003C/span>).\u003Cspan class=\"hljs-title function_ invoke__\">next\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">unwrap\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">parse\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">unwrap\u003C/span>();\n}\n\u003C/code>\u003C/pre>\u003Cp>In rust there are three kinds of enum variant fields, \u003Ccode>Named\u003C/code>, \u003Ccode>Unnamed\u003C/code>, and \u003Ccode>Unit\u003C/code>. Named means that the variant contains named fields (i.e. \u003Ccode>X { a: i32, b: f64 }\u003C/code>). Unnamed means that the variant is represented by a tuple (i.e. \u003Ccode>Y(i32, f64, bool)\u003C/code>). \u003Ccode>Unit\u003C/code> means the variant doesn&#39;t store any values (i.e. \u003Ccode>None\u003C/code>). For now, we only have \u003Ccode>Named\u003C/code> fields so let&#39;s deal with that.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-variable\">variant\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> input.variants {\n    \u003Cspan class=\"hljs-comment\">// ...\u003C/span>\n\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">Fields\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">Named\u003C/span>(field) = variant.fields {\n        \u003Cspan class=\"hljs-comment\">// Store the array of the methods we are calling\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">fns\u003C/span> = \u003Cspan class=\"hljs-type\">Vec\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>();\n\n        \u003Cspan class=\"hljs-comment\">// Iterate over each named field\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-variable\">field\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> fields.named {\n            \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">name\u003C/span> = field.ident.\u003Cspan class=\"hljs-title function_ invoke__\">as_ref\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">unwrap\u003C/span>();\n            \u003Cspan class=\"hljs-keyword\">if\u003C/span> \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">Type\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">Path\u003C/span>(ty) = &amp;field.ty {\n                \u003Cspan class=\"hljs-comment\">// Remember, we made Writer chainable so we can just join these\u003C/span>\n                \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">method\u003C/span> = \u003Cspan class=\"hljs-keyword\">match\u003C/span> ty.path.segments.\u003Cspan class=\"hljs-title function_ invoke__\">first\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">unwrap\u003C/span>().ident.\u003Cspan class=\"hljs-title function_ invoke__\">to_string\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">as_str\u003C/span>() {\n                    \u003Cspan class=\"hljs-string\">&quot;bool&quot;\u003C/span> =&gt; quote! { .\u003Cspan class=\"hljs-title function_ invoke__\">write_bool\u003C/span>(data.#name) },\n                    \u003Cspan class=\"hljs-string\">&quot;u8&quot;\u003C/span> =&gt; quote! { .\u003Cspan class=\"hljs-title function_ invoke__\">write_byte\u003C/span>(data.#name) },\n                    \u003Cspan class=\"hljs-string\">&quot;i16&quot;\u003C/span> =&gt; quote! { .\u003Cspan class=\"hljs-title function_ invoke__\">write_i16\u003C/span>(data.#name) },\n                    ty =&gt; quote! { compile_error!(\u003Cspan class=\"hljs-string\">&quot;Unknown type: {}&quot;\u003C/span>, #ty) },\n                }\n                \u003Cspan class=\"hljs-comment\">// Add the method\u003C/span>\n                fns.\u003Cspan class=\"hljs-title function_ invoke__\">push\u003C/span>(method)\n            }\n        }\n\n        \u003Cspan class=\"hljs-comment\">// # embeds the variable and #(#fns)* repeats fns\u003C/span>\n        cases.\u003Cspan class=\"hljs-title function_ invoke__\">push\u003C/span>(quote! { Message::#\u003Cspan class=\"hljs-title function_ invoke__\">name\u003C/span>(data) =&gt; \u003Cspan class=\"hljs-title function_ invoke__\">Ok\u003C/span>(Writer::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(#code)#(#fns)*.\u003Cspan class=\"hljs-title function_ invoke__\">finalize\u003C/span>()) })\n    }\n}\n\u003C/code>\u003C/pre>\u003Cp>Cool. What is \u003Ccode>quote!\u003C/code> doing, you may ask. It is taking the Rust code and converting it into a token stream. We now have our cases for each server-sent packet. Let&#39;s finally wrap them up in a match statement and get this show on the road. After our for loop, we are going to have this.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">sendable_from\u003C/span> = TokenStream::\u003Cspan class=\"hljs-title function_ invoke__\">from\u003C/span>(quote! {\n    \u003Cspan class=\"hljs-keyword\">impl\u003C/span>&lt;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span>&gt; TryFrom&lt;Message&lt;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span>&gt;&gt; \u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-title class_\">Vec\u003C/span>&lt;\u003Cspan class=\"hljs-type\">u8\u003C/span>&gt; {\n        \u003Cspan class=\"hljs-keyword\">type\u003C/span> \u003Cspan class=\"hljs-title class_\">Error\u003C/span> = &amp;\u003Cspan class=\"hljs-symbol\">&#x27;static\u003C/span> \u003Cspan class=\"hljs-type\">str\u003C/span>;\n\n        \u003Cspan class=\"hljs-keyword\">fn\u003C/span> \u003Cspan class=\"hljs-title function_\">try_from\u003C/span>(msg: Message) \u003Cspan class=\"hljs-punctuation\">-&gt;\u003C/span> \u003Cspan class=\"hljs-type\">Result\u003C/span>&lt;\u003Cspan class=\"hljs-keyword\">Self\u003C/span>, \u003Cspan class=\"hljs-keyword\">Self\u003C/span>::Error&gt; {\n            \u003Cspan class=\"hljs-keyword\">match\u003C/span> msg {\n                #(#cases),*, \u003Cspan class=\"hljs-comment\">// Join each case by a comma\u003C/span>\n                \u003Cspan class=\"hljs-comment\">// Our beloved special case\u003C/span>\n                Message::\u003Cspan class=\"hljs-title function_ invoke__\">Unknown\u003C/span>(code, buf) =&gt; \u003Cspan class=\"hljs-title function_ invoke__\">Ok\u003C/span>(Writer::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>(code).\u003Cspan class=\"hljs-title function_ invoke__\">write_bytes\u003C/span>(buf).\u003Cspan class=\"hljs-title function_ invoke__\">finalize\u003C/span>()),\n                _ =&gt; \u003Cspan class=\"hljs-title function_ invoke__\">Err\u003C/span>(\u003Cspan class=\"hljs-string\">&quot;Unserializable message. Consider using Message::Unknown&quot;\u003C/span>),\n            }\n        }\n    }\n});\n\u003C/code>\u003C/pre>\u003Cp>At this point, we are pretty much done. We just have to take our named fields and convert them to unnamed fields with the struct defined somewhere else. The rest of the code is just this.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-rs\">\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">structs\u003C/span> = \u003Cspan class=\"hljs-type\">Vec\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>();\n\u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-keyword\">mut \u003C/span>\u003Cspan class=\"hljs-variable\">variants\u003C/span> = \u003Cspan class=\"hljs-type\">Vec\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">new\u003C/span>();\n\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> \u003Cspan class=\"hljs-variable\">variant\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> input.variants {\n    \u003Cspan class=\"hljs-keyword\">if\u003C/span> \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">Fields\u003C/span>::\u003Cspan class=\"hljs-title function_ invoke__\">Named\u003C/span>(fields) = variant.fields {\n        \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">fields\u003C/span> = fields.named.\u003Cspan class=\"hljs-title function_ invoke__\">iter\u003C/span>().\u003Cspan class=\"hljs-title function_ invoke__\">map\u003C/span>(|e| {\n            \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">ident\u003C/span> = &amp;e.ident;\n            \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">ty\u003C/span> = &amp;e.ty;\n            quote!{ \u003Cspan class=\"hljs-keyword\">pub\u003C/span> #ident: #ty }\n        }); \u003Cspan class=\"hljs-comment\">// get the fields and make them public\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">let\u003C/span> \u003Cspan class=\"hljs-variable\">name\u003C/span> = variant.ident; \u003Cspan class=\"hljs-comment\">// get the name of the variant\u003C/span>\n        structs.\u003Cspan class=\"hljs-title function_ invoke__\">push\u003C/span>(quote! {\n            \u003Cspan class=\"hljs-meta\">#[derive(Debug, Clone)]\u003C/span>\n            \u003Cspan class=\"hljs-comment\">// construct a struct of the same name and fields\u003C/span>\n            \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">struct\u003C/span> #name {\n                #(#fields),*\n            }\n        });\n        variants.\u003Cspan class=\"hljs-title function_ invoke__\">push\u003C/span>(quote! { #\u003Cspan class=\"hljs-title function_ invoke__\">name\u003C/span>(#name) }) \u003Cspan class=\"hljs-comment\">// the new variant\u003C/span>\n    } \u003Cspan class=\"hljs-keyword\">else\u003C/span> {\n        variants.\u003Cspan class=\"hljs-title function_ invoke__\">push\u003C/span>(quote! { #variant }) \u003Cspan class=\"hljs-comment\">// nothing changes if it&#x27;s not named\u003C/span>\n    }\n}\n\nTokenStream::\u003Cspan class=\"hljs-title function_ invoke__\">from\u003C/span>(quote! {\n    #(#structs)* \u003Cspan class=\"hljs-comment\">// iterate over all our structs\u003C/span>\n    \u003Cspan class=\"hljs-meta\">#[derive(Debug, Clone)]\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">pub\u003C/span> \u003Cspan class=\"hljs-keyword\">enum\u003C/span> \u003Cspan class=\"hljs-title class_\">Message\u003C/span>&lt;\u003Cspan class=\"hljs-symbol\">&#x27;a\u003C/span>&gt; {\n        #(#variants),* \u003Cspan class=\"hljs-comment\">// include all our variants\u003C/span>\n    }\n    #sendable_from \u003Cspan class=\"hljs-comment\">// include our impl TryFrom\u003C/span>\n})\n\u003C/code>\u003C/pre>\u003Cp>There is, of course, much more to this. There are more types besides u8, i16, and bool. There&#39;s also more code for handling the client-sent readable packets. All of that is pretty much just doing what we did here but slightly differently. If you are interested in the full code for the \u003Ca href=\"https://github.com/xDimGG/trust/blob/main/macros/src/lib.rs\">macro\u003C/a>, the \u003Ca href=\"https://github.com/xDimGG/trust/blob/main/src/binary/reader.rs\">reader\u003C/a>, and the \u003Ca href=\"https://github.com/xDimGG/trust/blob/main/src/binary/writer.rs\">writer\u003C/a>, it&#39;s all in the \u003Ca href=\"https://github.com/xDimGG/trust\">repository\u003C/a>.\u003C/p>\n\u003Ch2>Closing Notes\u003C/h2>\n\u003Cp>Macro code can be hard to understand. I created this macro two years ago, and when I came back to it, I couldn&#39;t believe that I wrote it. The whole thing just seemed like gibberish. As a matter of fact, I had no intention to even touch the macro! However, when I tried compiling this project that I haven&#39;t touched in two years with a modern version of Rust, I received the following error.\u003C/p>\n\u003Cpre>\u003Ccode>error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n   --&gt; C:\\Users\\Dim\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\socket2-0.3.12\\src\\sockaddr.rs:176:9\n    |\n176 |         mem::transmute::&lt;SocketAddrV4, sockaddr_in&gt;(v4);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: source type: `SocketAddrV4` (48 bits)\n    = note: target type: `SOCKADDR_IN` (128 bits)\n\nFor more information about this error, try `rustc --explain E0512`.\n\u003C/code>\u003C/pre>\u003Cp>After a Google search, \u003Ca href=\"https://users.rust-lang.org/t/error-compiling-old-rust-project/83840\">this error\u003C/a> meant that one of my dependencies is outdated. That dependency turned out to be syn. I was on v1 and needed v2. I upgraded syn to v2, only to find out that the API has slightly changed so some lines were erroring. Because of that, I more or less had to re-understand my entire macro code again, which I really didn&#39;t want to do. Anyway, I did that and fixed it.\u003C/p>\n\u003Cp>However, this got me to thinking. Is there a way I could have made this code more readable? Well, not really. I think proc macros are generally quite hard to read without comments. I could and should probably add a bunch of comments to the code so that when future me has to re-visit this, he&#39;ll at least have a clue of what&#39;s going on... nahhh. Comments are for chumps.\u003C/p>\n\u003Cp>Anyway, that&#39;s all for now. Until we meet again in \u003Ca href=\"/blog/trust-3\">part 3\u003C/a>.\u003C/p>\n",title:"Writing Sweet Rust Macros (trust pt. 2)",date:1707829348111,tags:["macros","rust","trust"]},"uses":{"params":["id"]}}];

					Promise.all([
						import("../../_app/immutable/entry/start.b0cd14ac.js"),
						import("../../_app/immutable/entry/app.a8956f14.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
