<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../favicon.jpeg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" integrity="sha512-c42qTSw/wPZ3/5LBzD+Bw5f7bSF2oxou6wEb+I/lqeaKV5FDIfMvvRp772y4jcJLKuGUOpbJMdg/BTl50fJYAw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
		
		<link href="../../_app/immutable/assets/0.d949e681.css" rel="stylesheet">
		<link href="../../_app/immutable/assets/4.2a853ecf.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.7108e1ec.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/scheduler.e108d1fd.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/singletons.1f40050b.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.9590000c.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index.48054bed.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.accc4868.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/4.765ce7f2.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/each.e59479a4.js"><title>Finding Cheap Flight Tickets With Python</title><!-- HEAD_svelte-1n6ckfq_START --><link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet"><!-- HEAD_svelte-1n6ckfq_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">   <div class="min-h-screen w-full dark:bg-slate-900 px-3 py-8"><div class="prose prose-img:max-h-[80vh] prose-img:mx-auto prose-gray dark:prose-invert lg:max-w-[1000px] mx-auto"><div class="flex justify-between"><h1 class="mb-0">Finding Cheap Flight Tickets With Python</h1> <div class="block text-xs text-right text-opacity-50 shrink-0 ml-2"><a href="/blog/" class="xt-slate-500 dark:text-white block no-underline hover:underline" data-svelte-h="svelte-6j3ym0">other posts</a> <span class="text-slate-500 dark:text-slate-400">1/31/2024</span></div></div> <a href="/blog/?tag=data" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">data</a><span class="text-slate-500 dark:text-slate-400">, </span><a href="/blog/?tag=python" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">python</a><span class="text-slate-500 dark:text-slate-400">, </span><a href="/blog/?tag=scraping" class="no-underline text-xs hover:underline text-slate-500 dark:text-slate-400">scraping</a><span class="text-slate-500 dark:text-slate-400"></span> <!-- HTML_TAG_START --><p>A story on how I beat every travel site to the punch to book the best round-trip flights to South Korea. <a href="https://gist.github.com/xDimGG/eaf80e2dfac2e920ca023306b9e72437">TL;DR</a>.</p>
<h3>Some Background</h3>
<p>There is this relatively new airline called Air Premia that provides non-stop flights from four American airports to Incheon Airport in South Korea. As someone who lives near one of the four airports and is interested in visiting Korea, I wanted to capitalize on Air Premia&#39;s relatively cheap flight tickets.</p>
<h3>The Problem</h3>
<p>Because of how new Air Premia was, it still wasn&#39;t on the radar of many travel sites like Kayak and Expedia. It is now, but it wasn&#39;t then.</p>
<h3>The Solution</h3>
<p>Write a Python script to scrape data from Air Premia&#39;s site and go through that data to determine when the best time of year is to buy tickets and what tickets were cheapest.</p>
<h2>Getting Started</h2>
<p>For starters, let me show you what searching for tickets on <a href="https://www.airpremia.com/">Air Premia</a> looks like. First, you decide between Roundtrip and One-way. Next, you choose the airport you&#39;re departing form. Next, you choose the airport you&#39;re arriving at. Next, you click on the date. When clicking on the date, you get a brief loading screen followed by some calendar dates and a price for each applicable date.</p>
<p><img src="/premia_1.png" alt="Air Premia calendar UI"></p>
<p>Wowie, that&#39;s a lot of prices at once! After a bit of exploration, I found that you can only book flights up to 9 months in advance. After that, no more prices are shown.</p>
<h3>What is Happening?</h3>
<p>Well, when we click on the date selector or click on the arrows to load the next month, our browser is probably making an API request to get the prices given our parameters (departing from terminal, arriving at terminal, etc.). We can confirm that this is the case by opening up our Chrome developer tools and going to the network tab. With this tool, we can see every request that the current tab makes. Refreshing the page and choosing the same options as before, we are able to capture the following request.</p>
<p><img src="/premia_2.png" alt="Air Premia API request"></p>
<p>Okay, so our browser is making an HTTP GET request to <code>https://www.airpremia.com/pssapi/lowfare</code> with some query parameters. Let&#39;s format that URL so that we can actually read the parameters. <em>Note: you can see the same thing by going to the <code>Payload</code> tab of the request in Chrome.</em></p>
<pre><code>https://www.airpremia.com/pssapi/lowfare
    ?origin=EWR
    &amp;destination=ICN
    &amp;tripType=RT
    &amp;beginDate=2024-01-31
    &amp;endDate=2024-02-29
    &amp;loyalty=MonetaryOnly
    &amp;fareTypes=FI
    &amp;currency=USD
    &amp;useCache=true
</code></pre><p>Let&#39;s also take a look at the <code>Response</code> tab to see what data we&#39;re getting back.</p>
<p><img src="/premia_3.png" alt="Air Premia API response"></p>
<p>As far as reverse engineering APIs goes, Air Premia is definitely on the easier side of things. All the parameters are clearly written out and the response is in neatly structured JSON data. There are still some guesses we have to make regarding the data that we can confirm by making more requests.</p>
<p>So, in our request we have the obvious parameters <code>origin=EWR</code> and <code>destination=ICN</code>, both of which use <a href="https://en.wikipedia.org/wiki/IATA_airport_code">IATA Location Identifiers</a> (EWR for Newark Liberty International Airport and ICN for Incheon International Airport).</p>
<p>Then we have <code>tripType=RT</code>. We can guess that this means round-trip and verify this by selecting <code>One-way</code> from the UI and seeing that the request the browser sends contains <code>tripType=OW</code> instead.</p>
<p>Next is <code>beginDate=2024-01-31</code> and <code>endDate=2024-02-29</code>. These are also pretty obvious, but it&#39;s worth making a note that the format of these dates is <code>YYYY-MM-DD</code>.</p>
<p>We have <code>currency=USD</code>, which should be very obvious. Since Air Premia travels to Korea, Thailand, Tokyo, and the U.S., the possible currencies are most likely <code>KWN</code>, <code>THB</code>, <code>JPY</code>, and <code>USD</code>. This was confirmed by selecting one-way tickets and changing the departure terminals to different countries.</p>
<p>Finally, we also have <code>loyalty</code>, <code>fareTypes</code>, and <code>useCache</code>. These don&#39;t seem very useful so I&#39;ll just leave them as they are.</p>
<h3>Now What?</h3>
<p>Well, we figured out how the API works. Now, we need to write some code to make requests to these endpoints and store their data in some kind of data structure. I like working with <a href="https://jupyter.org/">Jupyter Notebook</a> since it lets you hold onto variables while writing your code. Anyway, let&#39;s import <code>requests</code> and try making a GET request to the endpoint with the same parameters as before, but just written out in a dictionary. <code>raise_for_status()</code> raises an error if our response has a bad status code. <code>json()</code> will just parse the response data in the JSON format.</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">import</span> requests

res = requests.get(
    <span class="hljs-string">&#x27;https://www.airpremia.com/pssapi/lowfare?loyalty=MonetaryOnly&amp;fareTypes=FI&amp;useCache=true&#x27;</span>,
    params={
        <span class="hljs-string">&#x27;tripType&#x27;</span>: <span class="hljs-string">&#x27;RT&#x27;</span>,
        <span class="hljs-string">&#x27;origin&#x27;</span>: <span class="hljs-string">&#x27;EWR&#x27;</span>,
        <span class="hljs-string">&#x27;destination&#x27;</span>: <span class="hljs-string">&#x27;ICN&#x27;</span>,
        <span class="hljs-string">&#x27;beginDate&#x27;</span>: <span class="hljs-string">&#x27;2024-01-31&#x27;</span>,
        <span class="hljs-string">&#x27;endDate&#x27;</span>: <span class="hljs-string">&#x27;2024-02-29&#x27;</span>,
        <span class="hljs-string">&#x27;currency&#x27;</span>: <span class="hljs-string">&#x27;USD&#x27;</span>,
    },
)
res.raise_for_status()
res.json()
</code></pre><p>Running this code, we get back <code>HTTPError: 400 Client Error</code>. Annoying but not unexpected. Client requests often require additional headers/cookies in order to work. In this case, after some guess and check of removing and adding headers, it turns out all we need is the <code>X-Content-ID</code> header. It doesn&#39;t even have to be set to anything... it just has to exist.</p>
<pre><code class="hljs language-diff">...
        &#x27;currency&#x27;: &#x27;USD&#x27;,
    },
<span class="hljs-addition">+	headers={&#x27;X-Context-ID&#x27;: &#x27;&#x27;},</span>
)
res.raise_for_status()
...
</code></pre><p>Running that code again, we now get a JSON response that looks something like this (after being parsed).</p>
<pre><code class="hljs language-py">{<span class="hljs-string">&#x27;data&#x27;</span>: {<span class="hljs-string">&#x27;EWR-ICN&#x27;</span>: [{<span class="hljs-string">&#x27;date&#x27;</span>: <span class="hljs-string">&#x27;2024-01-31&#x27;</span>,
    <span class="hljs-string">&#x27;soldOut&#x27;</span>: <span class="hljs-literal">False</span>,
    <span class="hljs-string">&#x27;noFights&#x27;</span>: <span class="hljs-literal">True</span>,
        <span class="hljs-comment"># ...</span>
  <span class="hljs-string">&#x27;ICN-EWR&#x27;</span>: [{<span class="hljs-string">&#x27;date&#x27;</span>: <span class="hljs-string">&#x27;2024-01-31&#x27;</span>,
    <span class="hljs-string">&#x27;soldOut&#x27;</span>: <span class="hljs-literal">False</span>,
    <span class="hljs-string">&#x27;noFights&#x27;</span>: <span class="hljs-literal">True</span>,
        <span class="hljs-comment"># ...</span>
    <span class="hljs-string">&#x27;PE&#x27;</span>: <span class="hljs-literal">None</span>}]}}
</code></pre><p>Since we are using <code>tripType=RT</code>, the response includes the costs for EWR to ICN and ICN to EWR. Let&#39;s create a list of dates that we&#39;re interested in iterating over. To do this, I&#39;m taking advantage of <a href="https://pypi.org/project/python-dateutil/">python-dateutil</a>, which provides some nice convenience methods for generating ranges of dates and mutating date objects.</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date
<span class="hljs-keyword">from</span> dateutil.rrule <span class="hljs-keyword">import</span> rrule, MONTHLY
<span class="hljs-keyword">from</span> dateutil.relativedelta <span class="hljs-keyword">import</span> relativedelta

<span class="hljs-comment"># Get today&#x27;s date and replace the day with 1 to be at the beginning of the month</span>
TODAY = date.today().replace(day=<span class="hljs-number">1</span>)
<span class="hljs-comment"># Starting from the current month, generate a range with 10 elements at a monthly frequency</span>
dates = <span class="hljs-built_in">list</span>(rrule(freq=MONTHLY, dtstart=TODAY, count=<span class="hljs-number">10</span>))
<span class="hljs-comment"># Set every other month&#x27;s date to the last day of the month</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(dates), <span class="hljs-number">2</span>):
    dates[i] += relativedelta(day=<span class="hljs-number">31</span>)

<span class="hljs-comment"># Format the dates in the format YYYY-MM-DD</span>
dates = [m.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> dates]
</code></pre><p>After running this code, our <code>dates</code> variable now contains this.</p>
<pre><code class="hljs language-py">[<span class="hljs-string">&#x27;2024-01-01&#x27;</span>,
 <span class="hljs-string">&#x27;2024-02-29&#x27;</span>,
 <span class="hljs-string">&#x27;2024-03-01&#x27;</span>,
 <span class="hljs-string">&#x27;2024-04-30&#x27;</span>,
 <span class="hljs-string">&#x27;2024-05-01&#x27;</span>,
 <span class="hljs-string">&#x27;2024-06-30&#x27;</span>,
 <span class="hljs-string">&#x27;2024-07-01&#x27;</span>,
 <span class="hljs-string">&#x27;2024-08-31&#x27;</span>,
 <span class="hljs-string">&#x27;2024-09-01&#x27;</span>,
 <span class="hljs-string">&#x27;2024-10-31&#x27;</span>]
</code></pre><p>Would it have been faster to type these out by hand? Yes, but it would not have been as fun.</p>
<p>With this done, let&#39;s start iterating over all the date ranges and getting flight data for all the possible dates. Mind you, we want to query two months at a time. This means that we will have <code>2024-01-01 through 2024-02-29</code>, <code>2024-03-01 through 2024-04-30</code>, and so on. We are matching every even indexed element with every odd indexed element. To do this, we may use Python&#39;s <a href="https://docs.python.org/3/library/functions.html#zip">zip</a> function and <a href="https://www.w3schools.com/python/numpy/numpy_array_slicing.asp">array slicing</a>.</p>
<p><code>dates[::2]</code> gives us every other element starting from 0 and <code>dates[1::2]</code> gives use every other element starting from 1. <em>Note: <code>dates[::2]</code> is implicitly <code>dates[0:len(dates):2]</code> and <code>dates[1::2]</code> is implicitly <code>dates[1:len(dates):2]</code>.</em> Now that we have these two iterators, we may merge them using <code>zip</code>. Let&#39;s just do <code>zip(dates[::2], dates[1::2])</code> and iterate over it to make sure everything works.</p>
<p><img src="/premia_4.png" alt="testing our use of zip"></p>
<p>Pay attention to the <code>start, end</code> in our loop. Each value of <code>zip()</code> is returned as a tuple and we can use comma-separated variables to extract the tuple&#39;s individual parts. With this done, we may begin making our GET requests. Let&#39;s just move our GET request to a function that takes some variables. If <code>trip_type</code> is RT, our method returns a tuple containg the flights to our destination and the return flights. If <code>trip_type</code> isn&#39;t RT, we return only flights going to our destination.</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">import</span> requests

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">trip_type, origin, destination, start_date, end_date, currency=<span class="hljs-string">&#x27;USD&#x27;</span></span>):
    res = requests.get(
        <span class="hljs-string">&#x27;https://www.airpremia.com/pssapi/lowfare?loyalty=MonetaryOnly&amp;fareTypes=FI&amp;useCache=true&#x27;</span>,
        params={
            <span class="hljs-string">&#x27;tripType&#x27;</span>: trip_type,
            <span class="hljs-string">&#x27;origin&#x27;</span>: origin,
            <span class="hljs-string">&#x27;destination&#x27;</span>: destination,
            <span class="hljs-string">&#x27;beginDate&#x27;</span>: start_date,
            <span class="hljs-string">&#x27;endDate&#x27;</span>: end_date,
            <span class="hljs-string">&#x27;currency&#x27;</span>: currency,
        },
        headers={<span class="hljs-string">&#x27;X-Context-ID&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>},
    )
    res.raise_for_status()
    data = res.json()[<span class="hljs-string">&#x27;data&#x27;</span>]
    going = data[<span class="hljs-string">f&#x27;<span class="hljs-subst">{origin}</span>-<span class="hljs-subst">{destination}</span>&#x27;</span>]

    <span class="hljs-keyword">return</span> (going, data[<span class="hljs-string">f&#x27;<span class="hljs-subst">{destination}</span>-<span class="hljs-subst">{origin}</span>&#x27;</span>]) <span class="hljs-keyword">if</span> trip_type == <span class="hljs-string">&#x27;RT&#x27;</span> <span class="hljs-keyword">else</span> going
</code></pre><p>Now, let&#39;s write a function like <code>fetch</code> called <code>fetch_all</code> that takes <code>trip_type</code>, <code>origin</code>, <code>destination</code>, and <code>currency</code>, and returns every single available flight. Here, we take advantage of <a href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor">concurrent.futures.ThreadPoolExecutor</a> to concurrently request all date ranges and compile them all into one or two arrays (depending on if <code>trip_type</code> is <code>RT</code> or <code>OW</code>). <em>Note: this whole OW/RT and value/2-tuple business and is very annoying to write code for. If you know a better way of doing this in Python, please advise.</em></p>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor

<span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_all</span>(<span class="hljs-params">trip_type, origin, destination, currency=<span class="hljs-string">&#x27;USD&#x27;</span></span>):
    going = []
    coming = []

    <span class="hljs-keyword">with</span> ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:
        <span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> executor.<span class="hljs-built_in">map</span>(
                <span class="hljs-keyword">lambda</span> args: fetch(trip_type, origin, destination, *args, currency),
                <span class="hljs-built_in">zip</span>(dates[::<span class="hljs-number">2</span>], dates[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>])):
            <span class="hljs-keyword">if</span> trip_type == <span class="hljs-string">&#x27;RT&#x27;</span>:
                going += res[<span class="hljs-number">0</span>]
                coming += res[<span class="hljs-number">1</span>]
            <span class="hljs-keyword">else</span>:
                going += res

    <span class="hljs-keyword">return</span> (going, coming) <span class="hljs-keyword">if</span> trip_type == <span class="hljs-string">&#x27;RT&#x27;</span> <span class="hljs-keyword">else</span> going
</code></pre><p>This blog post is already getting pretty long. Let me just briefly cover what the rest of the code does. Here, we are taking our arrays, filtering out days which don&#39;t have prices, flattening the data, and converting the data to <code>pandas.DataFrame</code> objects. The benefit of using pandas is that we get access to a lot of methods to assess our data. <em>Note: we are using &#39;E&#39; to represent economy. I mean, who&#39;d go to this extent saving money but also fly premium.</em></p>
<pre><code class="hljs language-py"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> dateutil.parser <span class="hljs-keyword">import</span> parse

<span class="hljs-comment"># c = &#x27;E&#x27; or &#x27;PE&#x27; (premium) economy</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">to_clean_df</span>(<span class="hljs-params">data, c=<span class="hljs-string">&#x27;E&#x27;</span></span>):
    clean = [{
        <span class="hljs-string">&#x27;date&#x27;</span>: parse(d[<span class="hljs-string">&#x27;date&#x27;</span>]),
        <span class="hljs-string">&#x27;available&#x27;</span>: d[c][<span class="hljs-string">&#x27;availableCount&#x27;</span>],
        <span class="hljs-string">&#x27;fare&#x27;</span>: d[c][<span class="hljs-string">&#x27;fareAmount&#x27;</span>],
        <span class="hljs-string">&#x27;fees&#x27;</span>: d[c][<span class="hljs-string">&#x27;taxesAndFeesAmount&#x27;</span>],
        <span class="hljs-string">&#x27;total&#x27;</span>: d[c][<span class="hljs-string">&#x27;fareAmount&#x27;</span>] + d[c][<span class="hljs-string">&#x27;taxesAndFeesAmount&#x27;</span>],
    } <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> d[c] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>]
    
    <span class="hljs-keyword">return</span> pd.DataFrame(clean).sort_values(<span class="hljs-string">&#x27;date&#x27;</span>)

icn_ow = to_clean_df(ewr_icn_ow) <span class="hljs-comment"># one-way ewr-icn</span>
ewr_ow = to_clean_df(icn_ewr_ow) <span class="hljs-comment"># one-way icn-ewr</span>
icn_rt = to_clean_df(ewr_icn_rt) <span class="hljs-comment"># round-trip price ewr-icn</span>
ewr_rt = to_clean_df(icn_ewr_rt) <span class="hljs-comment"># round-trip price icn-ewr</span>

<span class="hljs-keyword">assert</span> icn_ow.size == icn_rt.size
<span class="hljs-keyword">assert</span> ewr_ow.size == ewr_rt.size
</code></pre><p>Let&#39;s write a bit of code to find the <code>n</code> cheapest trips given a date range we want the trip to be during, the minimum number of days the trip should be, and the maximum number of days the trip should be. This code could be optimized by avoiding a lot of unnecessary iteration and using a heap queue. <em>Note: <code>leaving</code> and <code>returning</code> are <code>pandas.DataFrame</code> objects, not lists.</em></p>
<pre><code class="hljs language-py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">n_cheapest_trips</span>(<span class="hljs-params">leaving, returning, after, before, min_days=<span class="hljs-number">1</span>, max_days=<span class="hljs-number">270</span>, n=<span class="hljs-number">10</span></span>):
    after = parse(after)
    before = parse(before)
    <span class="hljs-comment"># a quick lookup map of dates to total costs for returning flights</span>
    r_map = {<span class="hljs-built_in">str</span>(d): t <span class="hljs-keyword">for</span> d, t <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(returning[<span class="hljs-string">&#x27;date&#x27;</span>], returning[<span class="hljs-string">&#x27;total&#x27;</span>])}
    n_best = []

    <span class="hljs-comment"># iterate over each leaving day</span>
    <span class="hljs-keyword">for</span> day <span class="hljs-keyword">in</span> leaving.itertuples():
        <span class="hljs-comment"># if the day is not within our date range, skip it</span>
        <span class="hljs-keyword">if</span> after &gt; day.date <span class="hljs-keyword">or</span> before &lt; day.date:
            <span class="hljs-keyword">continue</span>

        <span class="hljs-comment"># iterate over each number of days in the min, max range (inclusive)</span>
        <span class="hljs-keyword">for</span> days <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(min_days, max_days + <span class="hljs-number">1</span>):
            <span class="hljs-comment"># check if there is a returning flight available on current day + trip length</span>
            d = day.date + relativedelta(days=days)
            <span class="hljs-keyword">if</span> after &gt; d <span class="hljs-keyword">or</span> before &lt; d <span class="hljs-keyword">or</span> <span class="hljs-built_in">str</span>(d) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> r_map:
                <span class="hljs-keyword">continue</span>

            <span class="hljs-comment"># sum of leaving and returning cost</span>
            total_cost = day.total + r_map[<span class="hljs-built_in">str</span>(d)]
            <span class="hljs-comment"># update n best items, maintaining length &lt;= n</span>
            n_best += [(total_cost, day.date.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>), d.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>), days)]
            n_best = <span class="hljs-built_in">sorted</span>(n_best, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])
            n_best = n_best[:n]

    <span class="hljs-keyword">return</span> n_best
</code></pre><p>With this function, we can finally do what our original goal was, which is to find the best priced tickets. Let&#39;s suppose I want a 10 to 20 day trip between March 1, 2024 and May 31, 2024. Here is the result of that, using our round-trip data as input.</p>
<p><img src="/premia_7.png" alt="Air Premia best possible tickets given parameters"></p>
<p>It seems like we have quite a few options that are all $1,078. Let&#39;s see if we get a better price using our one-way data as input. Rather than buying both tickets together, you would have to purchase them separately.</p>
<p><img src="/premia_8.png" alt="Air Premia best possible tickets given parameters with one-way data"></p>
<p>As it turns out, we can actually get tickets for $57 cheaper by just buying two one-way tickets instead of round-trip tickets. I had always assumed that round-trip tickets would be cheaper than two one-way tickets, but I guess that&#39;s not always the case.</p>
<p>Mission complete. I still would like to plot some data so that we can get a sense for when tickets are cheaper and maybe uncover some other interesting patterns.</p>
<p>Let&#39;s import <a href="https://matplotlib.org/">matplotlib</a> so that we can do some data visualization. I&#39;m changing the default pyplot size and DPI to make the output wider and higher resolution.</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt
plt.rcParams[<span class="hljs-string">&#x27;figure.figsize&#x27;</span>] = (<span class="hljs-number">17</span>, <span class="hljs-number">4</span>)
plt.rcParams[<span class="hljs-string">&#x27;figure.dpi&#x27;</span>] = <span class="hljs-number">200</span>
</code></pre><p>Let&#39;s start by showing the prices for different days. I&#39;ll split this into two charts. One for one-way trips and another for round-trips. Some of the bars will overlap one another but you can still see the general pattern, which is what we&#39;re after. <em>Note: the code for round-trip tickets is almost identical.</em></p>
<pre><code class="hljs language-py">plt.title(<span class="hljs-string">&#x27;USD Cost of One-way Economy Tickets&#x27;</span>)
plt.bar(icn_ow[<span class="hljs-string">&#x27;date&#x27;</span>], icn_ow[<span class="hljs-string">&#x27;total&#x27;</span>], color=<span class="hljs-string">&#x27;C0&#x27;</span>, label=<span class="hljs-string">&#x27;EWR -&gt; ICN&#x27;</span>)
plt.bar(ewr_ow[<span class="hljs-string">&#x27;date&#x27;</span>], ewr_ow[<span class="hljs-string">&#x27;total&#x27;</span>], color=<span class="hljs-string">&#x27;C6&#x27;</span>, label=<span class="hljs-string">&#x27;ICN -&gt; EWR&#x27;</span>)
plt.legend()
plt.show()
</code></pre><p><img src="/premia_5.png" alt="Air Premia USD Cost of One-way Economy Tickets">
<img src="/premia_6.png" alt="Air Premia USD Cost of Round-trip Economy Tickets"></p>
<p>Let&#39;s check out what the price difference between one-way and round-trip tickets for the same flight is. We will use the following code which computes <code>one way cost - round trip cost</code>. If this number is positive, that means one-way costs more. If it&#39;s negative, round-trip costs more. <em>Note: the code for tickets to Newark is almost identical.</em></p>
<pre><code class="hljs language-py">plt.title(<span class="hljs-string">&#x27;USD Price Difference Between One-way and Round-trip Tickets to Incheon&#x27;</span>)
plt.bar(icn_ow[<span class="hljs-string">&#x27;date&#x27;</span>], icn_ow[<span class="hljs-string">&#x27;total&#x27;</span>] - icn_rt[<span class="hljs-string">&#x27;total&#x27;</span>], color=<span class="hljs-string">&#x27;C0&#x27;</span>)
plt.show()
</code></pre><p><img src="/premia_9.png" alt="Air Premia USD Price Difference Between One-way and Round-trip Tickets to Incheon">
<img src="/premia_10.png" alt="Air Premia USD Price Difference Between One-way and Round-trip Tickets to Newark"></p>
<p>Well now that we have a graphical understanding of the price difference, let&#39;s get a numerical sense for it by taking the mean of the differences.</p>
<pre><code class="hljs language-py">(icn_ow[<span class="hljs-string">&#x27;total&#x27;</span>] - icn_rt[<span class="hljs-string">&#x27;total&#x27;</span>]).mean(), (ewr_ow[<span class="hljs-string">&#x27;total&#x27;</span>] - ewr_rt[<span class="hljs-string">&#x27;total&#x27;</span>]).mean()
</code></pre><p>The result of this is about <code>(104.19, -137.54)</code>. This means that on average, you are saving $104.19 on the tickets to your location by buying round-trip, but you are losing $138.54 on the return tickets. A pair of round-trip tickets is about $33.35 more expensive than two one-way tickets.</p>
<h2>Conclusion</h2>
<p>Congratulations if you&#39;ve made it this far. You must really like data scraping. I hope you&#39;ve enjoyed and that you can take the data and create your own visualizations. As an aside, I did check if there was any price difference between currencies, but they all came out to about the same when converted to USD. Good luck and happy coding.</p>
<!-- HTML_TAG_END --></div></div> 
			
			<script>
				{
					__sveltekit_wlwwc1 = {
						base: new URL("../..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [null,{"type":"data","data":{id:"premia",content:"{\n\t\"title\": \"Finding Cheap Flight Tickets With Python\",\n\t\"date\": 1706727822114,\n\t\"tags\": [\"data\", \"scraping\", \"python\"]\n}\n---\n\nA story on how I beat every travel site to the punch to book the best round-trip flights to South Korea. [TL;DR](https://gist.github.com/xDimGG/eaf80e2dfac2e920ca023306b9e72437).\n\n### Some Background\n\nThere is this relatively new airline called Air Premia that provides non-stop flights from four American airports to Incheon Airport in South Korea. As someone who lives near one of the four airports and is interested in visiting Korea, I wanted to capitalize on Air Premia's relatively cheap flight tickets.\n\n### The Problem\n\nBecause of how new Air Premia was, it still wasn't on the radar of many travel sites like Kayak and Expedia. It is now, but it wasn't then.\n\n### The Solution\n\nWrite a Python script to scrape data from Air Premia's site and go through that data to determine when the best time of year is to buy tickets and what tickets were cheapest.\n\n## Getting Started\n\nFor starters, let me show you what searching for tickets on [Air Premia](https://www.airpremia.com/) looks like. First, you decide between Roundtrip and One-way. Next, you choose the airport you're departing form. Next, you choose the airport you're arriving at. Next, you click on the date. When clicking on the date, you get a brief loading screen followed by some calendar dates and a price for each applicable date.\n\n![Air Premia calendar UI](/premia_1.png)\n\nWowie, that's a lot of prices at once! After a bit of exploration, I found that you can only book flights up to 9 months in advance. After that, no more prices are shown.\n\n### What is Happening?\n\nWell, when we click on the date selector or click on the arrows to load the next month, our browser is probably making an API request to get the prices given our parameters (departing from terminal, arriving at terminal, etc.). We can confirm that this is the case by opening up our Chrome developer tools and going to the network tab. With this tool, we can see every request that the current tab makes. Refreshing the page and choosing the same options as before, we are able to capture the following request.\n\n![Air Premia API request](/premia_2.png)\n\nOkay, so our browser is making an HTTP GET request to `https://www.airpremia.com/pssapi/lowfare` with some query parameters. Let's format that URL so that we can actually read the parameters. *Note: you can see the same thing by going to the `Payload` tab of the request in Chrome.*\n\n```\nhttps://www.airpremia.com/pssapi/lowfare\n\t?origin=EWR\n\t&destination=ICN\n\t&tripType=RT\n\t&beginDate=2024-01-31\n\t&endDate=2024-02-29\n\t&loyalty=MonetaryOnly\n\t&fareTypes=FI\n\t&currency=USD\n\t&useCache=true\n```\n\nLet's also take a look at the `Response` tab to see what data we're getting back.\n\n![Air Premia API response](/premia_3.png)\n\nAs far as reverse engineering APIs goes, Air Premia is definitely on the easier side of things. All the parameters are clearly written out and the response is in neatly structured JSON data. There are still some guesses we have to make regarding the data that we can confirm by making more requests.\n\nSo, in our request we have the obvious parameters `origin=EWR` and `destination=ICN`, both of which use [IATA Location Identifiers](https://en.wikipedia.org/wiki/IATA_airport_code) (EWR for Newark Liberty International Airport and ICN for Incheon International Airport).\n\nThen we have `tripType=RT`. We can guess that this means round-trip and verify this by selecting `One-way` from the UI and seeing that the request the browser sends contains `tripType=OW` instead.\n\nNext is `beginDate=2024-01-31` and `endDate=2024-02-29`. These are also pretty obvious, but it's worth making a note that the format of these dates is `YYYY-MM-DD`.\n\nWe have `currency=USD`, which should be very obvious. Since Air Premia travels to Korea, Thailand, Tokyo, and the U.S., the possible currencies are most likely `KWN`, `THB`, `JPY`, and `USD`. This was confirmed by selecting one-way tickets and changing the departure terminals to different countries.\n\nFinally, we also have `loyalty`, `fareTypes`, and `useCache`. These don't seem very useful so I'll just leave them as they are.\n\n### Now What?\n\nWell, we figured out how the API works. Now, we need to write some code to make requests to these endpoints and store their data in some kind of data structure. I like working with [Jupyter Notebook](https://jupyter.org/) since it lets you hold onto variables while writing your code. Anyway, let's import `requests` and try making a GET request to the endpoint with the same parameters as before, but just written out in a dictionary. `raise_for_status()` raises an error if our response has a bad status code. `json()` will just parse the response data in the JSON format.\n\n```py\nimport requests\n\nres = requests.get(\n\t'https://www.airpremia.com/pssapi/lowfare?loyalty=MonetaryOnly&fareTypes=FI&useCache=true',\n\tparams={\n\t\t'tripType': 'RT',\n\t\t'origin': 'EWR',\n\t\t'destination': 'ICN',\n\t\t'beginDate': '2024-01-31',\n\t\t'endDate': '2024-02-29',\n\t\t'currency': 'USD',\n\t},\n)\nres.raise_for_status()\nres.json()\n```\n\nRunning this code, we get back `HTTPError: 400 Client Error`. Annoying but not unexpected. Client requests often require additional headers/cookies in order to work. In this case, after some guess and check of removing and adding headers, it turns out all we need is the `X-Content-ID` header. It doesn't even have to be set to anything... it just has to exist.\n\n```diff\n...\n\t\t'currency': 'USD',\n\t},\n+\theaders={'X-Context-ID': ''},\n)\nres.raise_for_status()\n...\n```\n\nRunning that code again, we now get a JSON response that looks something like this (after being parsed).\n\n```py\n{'data': {'EWR-ICN': [{'date': '2024-01-31',\n    'soldOut': False,\n    'noFights': True,\n\t\t# ...\n  'ICN-EWR': [{'date': '2024-01-31',\n    'soldOut': False,\n    'noFights': True,\n\t\t# ...\n    'PE': None}]}}\n```\n\nSince we are using `tripType=RT`, the response includes the costs for EWR to ICN and ICN to EWR. Let's create a list of dates that we're interested in iterating over. To do this, I'm taking advantage of [python-dateutil](https://pypi.org/project/python-dateutil/), which provides some nice convenience methods for generating ranges of dates and mutating date objects.\n\n```py\nfrom datetime import date\nfrom dateutil.rrule import rrule, MONTHLY\nfrom dateutil.relativedelta import relativedelta\n\n# Get today's date and replace the day with 1 to be at the beginning of the month\nTODAY = date.today().replace(day=1)\n# Starting from the current month, generate a range with 10 elements at a monthly frequency\ndates = list(rrule(freq=MONTHLY, dtstart=TODAY, count=10))\n# Set every other month's date to the last day of the month\nfor i in range(1, len(dates), 2):\n\tdates[i] += relativedelta(day=31)\n\n# Format the dates in the format YYYY-MM-DD\ndates = [m.strftime('%Y-%m-%d') for m in dates]\n```\n\nAfter running this code, our `dates` variable now contains this.\n\n```py\n['2024-01-01',\n '2024-02-29',\n '2024-03-01',\n '2024-04-30',\n '2024-05-01',\n '2024-06-30',\n '2024-07-01',\n '2024-08-31',\n '2024-09-01',\n '2024-10-31']\n```\n\nWould it have been faster to type these out by hand? Yes, but it would not have been as fun.\n\nWith this done, let's start iterating over all the date ranges and getting flight data for all the possible dates. Mind you, we want to query two months at a time. This means that we will have `2024-01-01 through 2024-02-29`, `2024-03-01 through 2024-04-30`, and so on. We are matching every even indexed element with every odd indexed element. To do this, we may use Python's [zip](https://docs.python.org/3/library/functions.html#zip) function and [array slicing](https://www.w3schools.com/python/numpy/numpy_array_slicing.asp).\n\n`dates[::2]` gives us every other element starting from 0 and `dates[1::2]` gives use every other element starting from 1. *Note: `dates[::2]` is implicitly `dates[0:len(dates):2]` and `dates[1::2]` is implicitly `dates[1:len(dates):2]`.* Now that we have these two iterators, we may merge them using `zip`. Let's just do `zip(dates[::2], dates[1::2])` and iterate over it to make sure everything works.\n\n![testing our use of zip](/premia_4.png)\n\nPay attention to the `start, end` in our loop. Each value of `zip()` is returned as a tuple and we can use comma-separated variables to extract the tuple's individual parts. With this done, we may begin making our GET requests. Let's just move our GET request to a function that takes some variables. If `trip_type` is RT, our method returns a tuple containg the flights to our destination and the return flights. If `trip_type` isn't RT, we return only flights going to our destination.\n\n```py\nimport requests\n\ndef fetch(trip_type, origin, destination, start_date, end_date, currency='USD'):\n\tres = requests.get(\n\t\t'https://www.airpremia.com/pssapi/lowfare?loyalty=MonetaryOnly&fareTypes=FI&useCache=true',\n\t\tparams={\n\t\t\t'tripType': trip_type,\n\t\t\t'origin': origin,\n\t\t\t'destination': destination,\n\t\t\t'beginDate': start_date,\n\t\t\t'endDate': end_date,\n\t\t\t'currency': currency,\n\t\t},\n\t\theaders={'X-Context-ID': ''},\n\t)\n\tres.raise_for_status()\n\tdata = res.json()['data']\n\tgoing = data[f'{origin}-{destination}']\n\n\treturn (going, data[f'{destination}-{origin}']) if trip_type == 'RT' else going\n```\n\nNow, let's write a function like `fetch` called `fetch_all` that takes `trip_type`, `origin`, `destination`, and `currency`, and returns every single available flight. Here, we take advantage of [concurrent.futures.ThreadPoolExecutor](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor) to concurrently request all date ranges and compile them all into one or two arrays (depending on if `trip_type` is `RT` or `OW`). *Note: this whole OW/RT and value/2-tuple business and is very annoying to write code for. If you know a better way of doing this in Python, please advise.*\n\n```py\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef fetch_all(trip_type, origin, destination, currency='USD'):\n\tgoing = []\n\tcoming = []\n\n\twith ThreadPoolExecutor() as executor:\n\t\tfor res in executor.map(\n\t\t\t\tlambda args: fetch(trip_type, origin, destination, *args, currency),\n\t\t\t\tzip(dates[::2], dates[1::2])):\n\t\t\tif trip_type == 'RT':\n\t\t\t\tgoing += res[0]\n\t\t\t\tcoming += res[1]\n\t\t\telse:\n\t\t\t\tgoing += res\n\n\treturn (going, coming) if trip_type == 'RT' else going\n```\n\nThis blog post is already getting pretty long. Let me just briefly cover what the rest of the code does. Here, we are taking our arrays, filtering out days which don't have prices, flattening the data, and converting the data to `pandas.DataFrame` objects. The benefit of using pandas is that we get access to a lot of methods to assess our data. *Note: we are using 'E' to represent economy. I mean, who'd go to this extent saving money but also fly premium.*\n\n```py\nimport pandas as pd\nfrom dateutil.parser import parse\n\n# c = 'E' or 'PE' (premium) economy\ndef to_clean_df(data, c='E'):\n\tclean = [{\n\t\t'date': parse(d['date']),\n\t\t'available': d[c]['availableCount'],\n\t\t'fare': d[c]['fareAmount'],\n\t\t'fees': d[c]['taxesAndFeesAmount'],\n\t\t'total': d[c]['fareAmount'] + d[c]['taxesAndFeesAmount'],\n\t} for d in data if d[c] is not None]\n\t\n\treturn pd.DataFrame(clean).sort_values('date')\n\nicn_ow = to_clean_df(ewr_icn_ow) # one-way ewr-icn\newr_ow = to_clean_df(icn_ewr_ow) # one-way icn-ewr\nicn_rt = to_clean_df(ewr_icn_rt) # round-trip price ewr-icn\newr_rt = to_clean_df(icn_ewr_rt) # round-trip price icn-ewr\n\nassert icn_ow.size == icn_rt.size\nassert ewr_ow.size == ewr_rt.size\n```\n\nLet's write a bit of code to find the `n` cheapest trips given a date range we want the trip to be during, the minimum number of days the trip should be, and the maximum number of days the trip should be. This code could be optimized by avoiding a lot of unnecessary iteration and using a heap queue. *Note: `leaving` and `returning` are `pandas.DataFrame` objects, not lists.*\n\n```py\ndef n_cheapest_trips(leaving, returning, after, before, min_days=1, max_days=270, n=10):\n\tafter = parse(after)\n\tbefore = parse(before)\n\t# a quick lookup map of dates to total costs for returning flights\n\tr_map = {str(d): t for d, t in zip(returning['date'], returning['total'])}\n\tn_best = []\n\n\t# iterate over each leaving day\n\tfor day in leaving.itertuples():\n\t\t# if the day is not within our date range, skip it\n\t\tif after > day.date or before \u003C day.date:\n\t\t\tcontinue\n\n\t\t# iterate over each number of days in the min, max range (inclusive)\n\t\tfor days in range(min_days, max_days + 1):\n\t\t\t# check if there is a returning flight available on current day + trip length\n\t\t\td = day.date + relativedelta(days=days)\n\t\t\tif after > d or before \u003C d or str(d) not in r_map:\n\t\t\t\tcontinue\n\n\t\t\t# sum of leaving and returning cost\n\t\t\ttotal_cost = day.total + r_map[str(d)]\n\t\t\t# update n best items, maintaining length \u003C= n\n\t\t\tn_best += [(total_cost, day.date.strftime('%Y-%m-%d'), d.strftime('%Y-%m-%d'), days)]\n\t\t\tn_best = sorted(n_best, key=lambda x: x[0])\n\t\t\tn_best = n_best[:n]\n\n\treturn n_best\n```\n\nWith this function, we can finally do what our original goal was, which is to find the best priced tickets. Let's suppose I want a 10 to 20 day trip between March 1, 2024 and May 31, 2024. Here is the result of that, using our round-trip data as input.\n\n![Air Premia best possible tickets given parameters](/premia_7.png)\n\nIt seems like we have quite a few options that are all $1,078. Let's see if we get a better price using our one-way data as input. Rather than buying both tickets together, you would have to purchase them separately.\n\n![Air Premia best possible tickets given parameters with one-way data](/premia_8.png)\n\nAs it turns out, we can actually get tickets for $57 cheaper by just buying two one-way tickets instead of round-trip tickets. I had always assumed that round-trip tickets would be cheaper than two one-way tickets, but I guess that's not always the case.\n\nMission complete. I still would like to plot some data so that we can get a sense for when tickets are cheaper and maybe uncover some other interesting patterns.\n\nLet's import [matplotlib](https://matplotlib.org/) so that we can do some data visualization. I'm changing the default pyplot size and DPI to make the output wider and higher resolution.\n\n```py\nfrom matplotlib import pyplot as plt\nplt.rcParams['figure.figsize'] = (17, 4)\nplt.rcParams['figure.dpi'] = 200\n```\n\nLet's start by showing the prices for different days. I'll split this into two charts. One for one-way trips and another for round-trips. Some of the bars will overlap one another but you can still see the general pattern, which is what we're after. *Note: the code for round-trip tickets is almost identical.*\n\n```py\nplt.title('USD Cost of One-way Economy Tickets')\nplt.bar(icn_ow['date'], icn_ow['total'], color='C0', label='EWR -> ICN')\nplt.bar(ewr_ow['date'], ewr_ow['total'], color='C6', label='ICN -> EWR')\nplt.legend()\nplt.show()\n```\n\n![Air Premia USD Cost of One-way Economy Tickets](/premia_5.png)\n![Air Premia USD Cost of Round-trip Economy Tickets](/premia_6.png)\n\nLet's check out what the price difference between one-way and round-trip tickets for the same flight is. We will use the following code which computes `one way cost - round trip cost`. If this number is positive, that means one-way costs more. If it's negative, round-trip costs more. *Note: the code for tickets to Newark is almost identical.*\n\n```py\nplt.title('USD Price Difference Between One-way and Round-trip Tickets to Incheon')\nplt.bar(icn_ow['date'], icn_ow['total'] - icn_rt['total'], color='C0')\nplt.show()\n```\n\n![Air Premia USD Price Difference Between One-way and Round-trip Tickets to Incheon](/premia_9.png)\n![Air Premia USD Price Difference Between One-way and Round-trip Tickets to Newark](/premia_10.png)\n\nWell now that we have a graphical understanding of the price difference, let's get a numerical sense for it by taking the mean of the differences.\n\n```py\n(icn_ow['total'] - icn_rt['total']).mean(), (ewr_ow['total'] - ewr_rt['total']).mean()\n```\n\nThe result of this is about `(104.19, -137.54)`. This means that on average, you are saving $104.19 on the tickets to your location by buying round-trip, but you are losing $138.54 on the return tickets. A pair of round-trip tickets is about $33.35 more expensive than two one-way tickets.\n\n## Conclusion\n\nCongratulations if you've made it this far. You must really like data scraping. I hope you've enjoyed and that you can take the data and create your own visualizations. As an aside, I did check if there was any price difference between currencies, but they all came out to about the same when converted to USD. Good luck and happy coding.\n",html:"\u003Cp>A story on how I beat every travel site to the punch to book the best round-trip flights to South Korea. \u003Ca href=\"https://gist.github.com/xDimGG/eaf80e2dfac2e920ca023306b9e72437\">TL;DR\u003C/a>.\u003C/p>\n\u003Ch3>Some Background\u003C/h3>\n\u003Cp>There is this relatively new airline called Air Premia that provides non-stop flights from four American airports to Incheon Airport in South Korea. As someone who lives near one of the four airports and is interested in visiting Korea, I wanted to capitalize on Air Premia&#39;s relatively cheap flight tickets.\u003C/p>\n\u003Ch3>The Problem\u003C/h3>\n\u003Cp>Because of how new Air Premia was, it still wasn&#39;t on the radar of many travel sites like Kayak and Expedia. It is now, but it wasn&#39;t then.\u003C/p>\n\u003Ch3>The Solution\u003C/h3>\n\u003Cp>Write a Python script to scrape data from Air Premia&#39;s site and go through that data to determine when the best time of year is to buy tickets and what tickets were cheapest.\u003C/p>\n\u003Ch2>Getting Started\u003C/h2>\n\u003Cp>For starters, let me show you what searching for tickets on \u003Ca href=\"https://www.airpremia.com/\">Air Premia\u003C/a> looks like. First, you decide between Roundtrip and One-way. Next, you choose the airport you&#39;re departing form. Next, you choose the airport you&#39;re arriving at. Next, you click on the date. When clicking on the date, you get a brief loading screen followed by some calendar dates and a price for each applicable date.\u003C/p>\n\u003Cp>\u003Cimg src=\"/premia_1.png\" alt=\"Air Premia calendar UI\">\u003C/p>\n\u003Cp>Wowie, that&#39;s a lot of prices at once! After a bit of exploration, I found that you can only book flights up to 9 months in advance. After that, no more prices are shown.\u003C/p>\n\u003Ch3>What is Happening?\u003C/h3>\n\u003Cp>Well, when we click on the date selector or click on the arrows to load the next month, our browser is probably making an API request to get the prices given our parameters (departing from terminal, arriving at terminal, etc.). We can confirm that this is the case by opening up our Chrome developer tools and going to the network tab. With this tool, we can see every request that the current tab makes. Refreshing the page and choosing the same options as before, we are able to capture the following request.\u003C/p>\n\u003Cp>\u003Cimg src=\"/premia_2.png\" alt=\"Air Premia API request\">\u003C/p>\n\u003Cp>Okay, so our browser is making an HTTP GET request to \u003Ccode>https://www.airpremia.com/pssapi/lowfare\u003C/code> with some query parameters. Let&#39;s format that URL so that we can actually read the parameters. \u003Cem>Note: you can see the same thing by going to the \u003Ccode>Payload\u003C/code> tab of the request in Chrome.\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode>https://www.airpremia.com/pssapi/lowfare\n    ?origin=EWR\n    &amp;destination=ICN\n    &amp;tripType=RT\n    &amp;beginDate=2024-01-31\n    &amp;endDate=2024-02-29\n    &amp;loyalty=MonetaryOnly\n    &amp;fareTypes=FI\n    &amp;currency=USD\n    &amp;useCache=true\n\u003C/code>\u003C/pre>\u003Cp>Let&#39;s also take a look at the \u003Ccode>Response\u003C/code> tab to see what data we&#39;re getting back.\u003C/p>\n\u003Cp>\u003Cimg src=\"/premia_3.png\" alt=\"Air Premia API response\">\u003C/p>\n\u003Cp>As far as reverse engineering APIs goes, Air Premia is definitely on the easier side of things. All the parameters are clearly written out and the response is in neatly structured JSON data. There are still some guesses we have to make regarding the data that we can confirm by making more requests.\u003C/p>\n\u003Cp>So, in our request we have the obvious parameters \u003Ccode>origin=EWR\u003C/code> and \u003Ccode>destination=ICN\u003C/code>, both of which use \u003Ca href=\"https://en.wikipedia.org/wiki/IATA_airport_code\">IATA Location Identifiers\u003C/a> (EWR for Newark Liberty International Airport and ICN for Incheon International Airport).\u003C/p>\n\u003Cp>Then we have \u003Ccode>tripType=RT\u003C/code>. We can guess that this means round-trip and verify this by selecting \u003Ccode>One-way\u003C/code> from the UI and seeing that the request the browser sends contains \u003Ccode>tripType=OW\u003C/code> instead.\u003C/p>\n\u003Cp>Next is \u003Ccode>beginDate=2024-01-31\u003C/code> and \u003Ccode>endDate=2024-02-29\u003C/code>. These are also pretty obvious, but it&#39;s worth making a note that the format of these dates is \u003Ccode>YYYY-MM-DD\u003C/code>.\u003C/p>\n\u003Cp>We have \u003Ccode>currency=USD\u003C/code>, which should be very obvious. Since Air Premia travels to Korea, Thailand, Tokyo, and the U.S., the possible currencies are most likely \u003Ccode>KWN\u003C/code>, \u003Ccode>THB\u003C/code>, \u003Ccode>JPY\u003C/code>, and \u003Ccode>USD\u003C/code>. This was confirmed by selecting one-way tickets and changing the departure terminals to different countries.\u003C/p>\n\u003Cp>Finally, we also have \u003Ccode>loyalty\u003C/code>, \u003Ccode>fareTypes\u003C/code>, and \u003Ccode>useCache\u003C/code>. These don&#39;t seem very useful so I&#39;ll just leave them as they are.\u003C/p>\n\u003Ch3>Now What?\u003C/h3>\n\u003Cp>Well, we figured out how the API works. Now, we need to write some code to make requests to these endpoints and store their data in some kind of data structure. I like working with \u003Ca href=\"https://jupyter.org/\">Jupyter Notebook\u003C/a> since it lets you hold onto variables while writing your code. Anyway, let&#39;s import \u003Ccode>requests\u003C/code> and try making a GET request to the endpoint with the same parameters as before, but just written out in a dictionary. \u003Ccode>raise_for_status()\u003C/code> raises an error if our response has a bad status code. \u003Ccode>json()\u003C/code> will just parse the response data in the JSON format.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">import\u003C/span> requests\n\nres = requests.get(\n    \u003Cspan class=\"hljs-string\">&#x27;https://www.airpremia.com/pssapi/lowfare?loyalty=MonetaryOnly&amp;fareTypes=FI&amp;useCache=true&#x27;\u003C/span>,\n    params={\n        \u003Cspan class=\"hljs-string\">&#x27;tripType&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;RT&#x27;\u003C/span>,\n        \u003Cspan class=\"hljs-string\">&#x27;origin&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;EWR&#x27;\u003C/span>,\n        \u003Cspan class=\"hljs-string\">&#x27;destination&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;ICN&#x27;\u003C/span>,\n        \u003Cspan class=\"hljs-string\">&#x27;beginDate&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;2024-01-31&#x27;\u003C/span>,\n        \u003Cspan class=\"hljs-string\">&#x27;endDate&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;2024-02-29&#x27;\u003C/span>,\n        \u003Cspan class=\"hljs-string\">&#x27;currency&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;USD&#x27;\u003C/span>,\n    },\n)\nres.raise_for_status()\nres.json()\n\u003C/code>\u003C/pre>\u003Cp>Running this code, we get back \u003Ccode>HTTPError: 400 Client Error\u003C/code>. Annoying but not unexpected. Client requests often require additional headers/cookies in order to work. In this case, after some guess and check of removing and adding headers, it turns out all we need is the \u003Ccode>X-Content-ID\u003C/code> header. It doesn&#39;t even have to be set to anything... it just has to exist.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-diff\">...\n        &#x27;currency&#x27;: &#x27;USD&#x27;,\n    },\n\u003Cspan class=\"hljs-addition\">+\theaders={&#x27;X-Context-ID&#x27;: &#x27;&#x27;},\u003C/span>\n)\nres.raise_for_status()\n...\n\u003C/code>\u003C/pre>\u003Cp>Running that code again, we now get a JSON response that looks something like this (after being parsed).\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">{\u003Cspan class=\"hljs-string\">&#x27;data&#x27;\u003C/span>: {\u003Cspan class=\"hljs-string\">&#x27;EWR-ICN&#x27;\u003C/span>: [{\u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;2024-01-31&#x27;\u003C/span>,\n    \u003Cspan class=\"hljs-string\">&#x27;soldOut&#x27;\u003C/span>: \u003Cspan class=\"hljs-literal\">False\u003C/span>,\n    \u003Cspan class=\"hljs-string\">&#x27;noFights&#x27;\u003C/span>: \u003Cspan class=\"hljs-literal\">True\u003C/span>,\n        \u003Cspan class=\"hljs-comment\"># ...\u003C/span>\n  \u003Cspan class=\"hljs-string\">&#x27;ICN-EWR&#x27;\u003C/span>: [{\u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;2024-01-31&#x27;\u003C/span>,\n    \u003Cspan class=\"hljs-string\">&#x27;soldOut&#x27;\u003C/span>: \u003Cspan class=\"hljs-literal\">False\u003C/span>,\n    \u003Cspan class=\"hljs-string\">&#x27;noFights&#x27;\u003C/span>: \u003Cspan class=\"hljs-literal\">True\u003C/span>,\n        \u003Cspan class=\"hljs-comment\"># ...\u003C/span>\n    \u003Cspan class=\"hljs-string\">&#x27;PE&#x27;\u003C/span>: \u003Cspan class=\"hljs-literal\">None\u003C/span>}]}}\n\u003C/code>\u003C/pre>\u003Cp>Since we are using \u003Ccode>tripType=RT\u003C/code>, the response includes the costs for EWR to ICN and ICN to EWR. Let&#39;s create a list of dates that we&#39;re interested in iterating over. To do this, I&#39;m taking advantage of \u003Ca href=\"https://pypi.org/project/python-dateutil/\">python-dateutil\u003C/a>, which provides some nice convenience methods for generating ranges of dates and mutating date objects.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">from\u003C/span> datetime \u003Cspan class=\"hljs-keyword\">import\u003C/span> date\n\u003Cspan class=\"hljs-keyword\">from\u003C/span> dateutil.rrule \u003Cspan class=\"hljs-keyword\">import\u003C/span> rrule, MONTHLY\n\u003Cspan class=\"hljs-keyword\">from\u003C/span> dateutil.relativedelta \u003Cspan class=\"hljs-keyword\">import\u003C/span> relativedelta\n\n\u003Cspan class=\"hljs-comment\"># Get today&#x27;s date and replace the day with 1 to be at the beginning of the month\u003C/span>\nTODAY = date.today().replace(day=\u003Cspan class=\"hljs-number\">1\u003C/span>)\n\u003Cspan class=\"hljs-comment\"># Starting from the current month, generate a range with 10 elements at a monthly frequency\u003C/span>\ndates = \u003Cspan class=\"hljs-built_in\">list\u003C/span>(rrule(freq=MONTHLY, dtstart=TODAY, count=\u003Cspan class=\"hljs-number\">10\u003C/span>))\n\u003Cspan class=\"hljs-comment\"># Set every other month&#x27;s date to the last day of the month\u003C/span>\n\u003Cspan class=\"hljs-keyword\">for\u003C/span> i \u003Cspan class=\"hljs-keyword\">in\u003C/span> \u003Cspan class=\"hljs-built_in\">range\u003C/span>(\u003Cspan class=\"hljs-number\">1\u003C/span>, \u003Cspan class=\"hljs-built_in\">len\u003C/span>(dates), \u003Cspan class=\"hljs-number\">2\u003C/span>):\n    dates[i] += relativedelta(day=\u003Cspan class=\"hljs-number\">31\u003C/span>)\n\n\u003Cspan class=\"hljs-comment\"># Format the dates in the format YYYY-MM-DD\u003C/span>\ndates = [m.strftime(\u003Cspan class=\"hljs-string\">&#x27;%Y-%m-%d&#x27;\u003C/span>) \u003Cspan class=\"hljs-keyword\">for\u003C/span> m \u003Cspan class=\"hljs-keyword\">in\u003C/span> dates]\n\u003C/code>\u003C/pre>\u003Cp>After running this code, our \u003Ccode>dates\u003C/code> variable now contains this.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">[\u003Cspan class=\"hljs-string\">&#x27;2024-01-01&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-02-29&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-03-01&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-04-30&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-05-01&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-06-30&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-07-01&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-08-31&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-09-01&#x27;\u003C/span>,\n \u003Cspan class=\"hljs-string\">&#x27;2024-10-31&#x27;\u003C/span>]\n\u003C/code>\u003C/pre>\u003Cp>Would it have been faster to type these out by hand? Yes, but it would not have been as fun.\u003C/p>\n\u003Cp>With this done, let&#39;s start iterating over all the date ranges and getting flight data for all the possible dates. Mind you, we want to query two months at a time. This means that we will have \u003Ccode>2024-01-01 through 2024-02-29\u003C/code>, \u003Ccode>2024-03-01 through 2024-04-30\u003C/code>, and so on. We are matching every even indexed element with every odd indexed element. To do this, we may use Python&#39;s \u003Ca href=\"https://docs.python.org/3/library/functions.html#zip\">zip\u003C/a> function and \u003Ca href=\"https://www.w3schools.com/python/numpy/numpy_array_slicing.asp\">array slicing\u003C/a>.\u003C/p>\n\u003Cp>\u003Ccode>dates[::2]\u003C/code> gives us every other element starting from 0 and \u003Ccode>dates[1::2]\u003C/code> gives use every other element starting from 1. \u003Cem>Note: \u003Ccode>dates[::2]\u003C/code> is implicitly \u003Ccode>dates[0:len(dates):2]\u003C/code> and \u003Ccode>dates[1::2]\u003C/code> is implicitly \u003Ccode>dates[1:len(dates):2]\u003C/code>.\u003C/em> Now that we have these two iterators, we may merge them using \u003Ccode>zip\u003C/code>. Let&#39;s just do \u003Ccode>zip(dates[::2], dates[1::2])\u003C/code> and iterate over it to make sure everything works.\u003C/p>\n\u003Cp>\u003Cimg src=\"/premia_4.png\" alt=\"testing our use of zip\">\u003C/p>\n\u003Cp>Pay attention to the \u003Ccode>start, end\u003C/code> in our loop. Each value of \u003Ccode>zip()\u003C/code> is returned as a tuple and we can use comma-separated variables to extract the tuple&#39;s individual parts. With this done, we may begin making our GET requests. Let&#39;s just move our GET request to a function that takes some variables. If \u003Ccode>trip_type\u003C/code> is RT, our method returns a tuple containg the flights to our destination and the return flights. If \u003Ccode>trip_type\u003C/code> isn&#39;t RT, we return only flights going to our destination.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">import\u003C/span> requests\n\n\u003Cspan class=\"hljs-keyword\">def\u003C/span> \u003Cspan class=\"hljs-title function_\">fetch\u003C/span>(\u003Cspan class=\"hljs-params\">trip_type, origin, destination, start_date, end_date, currency=\u003Cspan class=\"hljs-string\">&#x27;USD&#x27;\u003C/span>\u003C/span>):\n    res = requests.get(\n        \u003Cspan class=\"hljs-string\">&#x27;https://www.airpremia.com/pssapi/lowfare?loyalty=MonetaryOnly&amp;fareTypes=FI&amp;useCache=true&#x27;\u003C/span>,\n        params={\n            \u003Cspan class=\"hljs-string\">&#x27;tripType&#x27;\u003C/span>: trip_type,\n            \u003Cspan class=\"hljs-string\">&#x27;origin&#x27;\u003C/span>: origin,\n            \u003Cspan class=\"hljs-string\">&#x27;destination&#x27;\u003C/span>: destination,\n            \u003Cspan class=\"hljs-string\">&#x27;beginDate&#x27;\u003C/span>: start_date,\n            \u003Cspan class=\"hljs-string\">&#x27;endDate&#x27;\u003C/span>: end_date,\n            \u003Cspan class=\"hljs-string\">&#x27;currency&#x27;\u003C/span>: currency,\n        },\n        headers={\u003Cspan class=\"hljs-string\">&#x27;X-Context-ID&#x27;\u003C/span>: \u003Cspan class=\"hljs-string\">&#x27;&#x27;\u003C/span>},\n    )\n    res.raise_for_status()\n    data = res.json()[\u003Cspan class=\"hljs-string\">&#x27;data&#x27;\u003C/span>]\n    going = data[\u003Cspan class=\"hljs-string\">f&#x27;\u003Cspan class=\"hljs-subst\">{origin}\u003C/span>-\u003Cspan class=\"hljs-subst\">{destination}\u003C/span>&#x27;\u003C/span>]\n\n    \u003Cspan class=\"hljs-keyword\">return\u003C/span> (going, data[\u003Cspan class=\"hljs-string\">f&#x27;\u003Cspan class=\"hljs-subst\">{destination}\u003C/span>-\u003Cspan class=\"hljs-subst\">{origin}\u003C/span>&#x27;\u003C/span>]) \u003Cspan class=\"hljs-keyword\">if\u003C/span> trip_type == \u003Cspan class=\"hljs-string\">&#x27;RT&#x27;\u003C/span> \u003Cspan class=\"hljs-keyword\">else\u003C/span> going\n\u003C/code>\u003C/pre>\u003Cp>Now, let&#39;s write a function like \u003Ccode>fetch\u003C/code> called \u003Ccode>fetch_all\u003C/code> that takes \u003Ccode>trip_type\u003C/code>, \u003Ccode>origin\u003C/code>, \u003Ccode>destination\u003C/code>, and \u003Ccode>currency\u003C/code>, and returns every single available flight. Here, we take advantage of \u003Ca href=\"https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor\">concurrent.futures.ThreadPoolExecutor\u003C/a> to concurrently request all date ranges and compile them all into one or two arrays (depending on if \u003Ccode>trip_type\u003C/code> is \u003Ccode>RT\u003C/code> or \u003Ccode>OW\u003C/code>). \u003Cem>Note: this whole OW/RT and value/2-tuple business and is very annoying to write code for. If you know a better way of doing this in Python, please advise.\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">from\u003C/span> concurrent.futures \u003Cspan class=\"hljs-keyword\">import\u003C/span> ThreadPoolExecutor\n\n\u003Cspan class=\"hljs-keyword\">def\u003C/span> \u003Cspan class=\"hljs-title function_\">fetch_all\u003C/span>(\u003Cspan class=\"hljs-params\">trip_type, origin, destination, currency=\u003Cspan class=\"hljs-string\">&#x27;USD&#x27;\u003C/span>\u003C/span>):\n    going = []\n    coming = []\n\n    \u003Cspan class=\"hljs-keyword\">with\u003C/span> ThreadPoolExecutor() \u003Cspan class=\"hljs-keyword\">as\u003C/span> executor:\n        \u003Cspan class=\"hljs-keyword\">for\u003C/span> res \u003Cspan class=\"hljs-keyword\">in\u003C/span> executor.\u003Cspan class=\"hljs-built_in\">map\u003C/span>(\n                \u003Cspan class=\"hljs-keyword\">lambda\u003C/span> args: fetch(trip_type, origin, destination, *args, currency),\n                \u003Cspan class=\"hljs-built_in\">zip\u003C/span>(dates[::\u003Cspan class=\"hljs-number\">2\u003C/span>], dates[\u003Cspan class=\"hljs-number\">1\u003C/span>::\u003Cspan class=\"hljs-number\">2\u003C/span>])):\n            \u003Cspan class=\"hljs-keyword\">if\u003C/span> trip_type == \u003Cspan class=\"hljs-string\">&#x27;RT&#x27;\u003C/span>:\n                going += res[\u003Cspan class=\"hljs-number\">0\u003C/span>]\n                coming += res[\u003Cspan class=\"hljs-number\">1\u003C/span>]\n            \u003Cspan class=\"hljs-keyword\">else\u003C/span>:\n                going += res\n\n    \u003Cspan class=\"hljs-keyword\">return\u003C/span> (going, coming) \u003Cspan class=\"hljs-keyword\">if\u003C/span> trip_type == \u003Cspan class=\"hljs-string\">&#x27;RT&#x27;\u003C/span> \u003Cspan class=\"hljs-keyword\">else\u003C/span> going\n\u003C/code>\u003C/pre>\u003Cp>This blog post is already getting pretty long. Let me just briefly cover what the rest of the code does. Here, we are taking our arrays, filtering out days which don&#39;t have prices, flattening the data, and converting the data to \u003Ccode>pandas.DataFrame\u003C/code> objects. The benefit of using pandas is that we get access to a lot of methods to assess our data. \u003Cem>Note: we are using &#39;E&#39; to represent economy. I mean, who&#39;d go to this extent saving money but also fly premium.\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">import\u003C/span> pandas \u003Cspan class=\"hljs-keyword\">as\u003C/span> pd\n\u003Cspan class=\"hljs-keyword\">from\u003C/span> dateutil.parser \u003Cspan class=\"hljs-keyword\">import\u003C/span> parse\n\n\u003Cspan class=\"hljs-comment\"># c = &#x27;E&#x27; or &#x27;PE&#x27; (premium) economy\u003C/span>\n\u003Cspan class=\"hljs-keyword\">def\u003C/span> \u003Cspan class=\"hljs-title function_\">to_clean_df\u003C/span>(\u003Cspan class=\"hljs-params\">data, c=\u003Cspan class=\"hljs-string\">&#x27;E&#x27;\u003C/span>\u003C/span>):\n    clean = [{\n        \u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>: parse(d[\u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>]),\n        \u003Cspan class=\"hljs-string\">&#x27;available&#x27;\u003C/span>: d[c][\u003Cspan class=\"hljs-string\">&#x27;availableCount&#x27;\u003C/span>],\n        \u003Cspan class=\"hljs-string\">&#x27;fare&#x27;\u003C/span>: d[c][\u003Cspan class=\"hljs-string\">&#x27;fareAmount&#x27;\u003C/span>],\n        \u003Cspan class=\"hljs-string\">&#x27;fees&#x27;\u003C/span>: d[c][\u003Cspan class=\"hljs-string\">&#x27;taxesAndFeesAmount&#x27;\u003C/span>],\n        \u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>: d[c][\u003Cspan class=\"hljs-string\">&#x27;fareAmount&#x27;\u003C/span>] + d[c][\u003Cspan class=\"hljs-string\">&#x27;taxesAndFeesAmount&#x27;\u003C/span>],\n    } \u003Cspan class=\"hljs-keyword\">for\u003C/span> d \u003Cspan class=\"hljs-keyword\">in\u003C/span> data \u003Cspan class=\"hljs-keyword\">if\u003C/span> d[c] \u003Cspan class=\"hljs-keyword\">is\u003C/span> \u003Cspan class=\"hljs-keyword\">not\u003C/span> \u003Cspan class=\"hljs-literal\">None\u003C/span>]\n    \n    \u003Cspan class=\"hljs-keyword\">return\u003C/span> pd.DataFrame(clean).sort_values(\u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>)\n\nicn_ow = to_clean_df(ewr_icn_ow) \u003Cspan class=\"hljs-comment\"># one-way ewr-icn\u003C/span>\newr_ow = to_clean_df(icn_ewr_ow) \u003Cspan class=\"hljs-comment\"># one-way icn-ewr\u003C/span>\nicn_rt = to_clean_df(ewr_icn_rt) \u003Cspan class=\"hljs-comment\"># round-trip price ewr-icn\u003C/span>\newr_rt = to_clean_df(icn_ewr_rt) \u003Cspan class=\"hljs-comment\"># round-trip price icn-ewr\u003C/span>\n\n\u003Cspan class=\"hljs-keyword\">assert\u003C/span> icn_ow.size == icn_rt.size\n\u003Cspan class=\"hljs-keyword\">assert\u003C/span> ewr_ow.size == ewr_rt.size\n\u003C/code>\u003C/pre>\u003Cp>Let&#39;s write a bit of code to find the \u003Ccode>n\u003C/code> cheapest trips given a date range we want the trip to be during, the minimum number of days the trip should be, and the maximum number of days the trip should be. This code could be optimized by avoiding a lot of unnecessary iteration and using a heap queue. \u003Cem>Note: \u003Ccode>leaving\u003C/code> and \u003Ccode>returning\u003C/code> are \u003Ccode>pandas.DataFrame\u003C/code> objects, not lists.\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">def\u003C/span> \u003Cspan class=\"hljs-title function_\">n_cheapest_trips\u003C/span>(\u003Cspan class=\"hljs-params\">leaving, returning, after, before, min_days=\u003Cspan class=\"hljs-number\">1\u003C/span>, max_days=\u003Cspan class=\"hljs-number\">270\u003C/span>, n=\u003Cspan class=\"hljs-number\">10\u003C/span>\u003C/span>):\n    after = parse(after)\n    before = parse(before)\n    \u003Cspan class=\"hljs-comment\"># a quick lookup map of dates to total costs for returning flights\u003C/span>\n    r_map = {\u003Cspan class=\"hljs-built_in\">str\u003C/span>(d): t \u003Cspan class=\"hljs-keyword\">for\u003C/span> d, t \u003Cspan class=\"hljs-keyword\">in\u003C/span> \u003Cspan class=\"hljs-built_in\">zip\u003C/span>(returning[\u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>], returning[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>])}\n    n_best = []\n\n    \u003Cspan class=\"hljs-comment\"># iterate over each leaving day\u003C/span>\n    \u003Cspan class=\"hljs-keyword\">for\u003C/span> day \u003Cspan class=\"hljs-keyword\">in\u003C/span> leaving.itertuples():\n        \u003Cspan class=\"hljs-comment\"># if the day is not within our date range, skip it\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">if\u003C/span> after &gt; day.date \u003Cspan class=\"hljs-keyword\">or\u003C/span> before &lt; day.date:\n            \u003Cspan class=\"hljs-keyword\">continue\u003C/span>\n\n        \u003Cspan class=\"hljs-comment\"># iterate over each number of days in the min, max range (inclusive)\u003C/span>\n        \u003Cspan class=\"hljs-keyword\">for\u003C/span> days \u003Cspan class=\"hljs-keyword\">in\u003C/span> \u003Cspan class=\"hljs-built_in\">range\u003C/span>(min_days, max_days + \u003Cspan class=\"hljs-number\">1\u003C/span>):\n            \u003Cspan class=\"hljs-comment\"># check if there is a returning flight available on current day + trip length\u003C/span>\n            d = day.date + relativedelta(days=days)\n            \u003Cspan class=\"hljs-keyword\">if\u003C/span> after &gt; d \u003Cspan class=\"hljs-keyword\">or\u003C/span> before &lt; d \u003Cspan class=\"hljs-keyword\">or\u003C/span> \u003Cspan class=\"hljs-built_in\">str\u003C/span>(d) \u003Cspan class=\"hljs-keyword\">not\u003C/span> \u003Cspan class=\"hljs-keyword\">in\u003C/span> r_map:\n                \u003Cspan class=\"hljs-keyword\">continue\u003C/span>\n\n            \u003Cspan class=\"hljs-comment\"># sum of leaving and returning cost\u003C/span>\n            total_cost = day.total + r_map[\u003Cspan class=\"hljs-built_in\">str\u003C/span>(d)]\n            \u003Cspan class=\"hljs-comment\"># update n best items, maintaining length &lt;= n\u003C/span>\n            n_best += [(total_cost, day.date.strftime(\u003Cspan class=\"hljs-string\">&#x27;%Y-%m-%d&#x27;\u003C/span>), d.strftime(\u003Cspan class=\"hljs-string\">&#x27;%Y-%m-%d&#x27;\u003C/span>), days)]\n            n_best = \u003Cspan class=\"hljs-built_in\">sorted\u003C/span>(n_best, key=\u003Cspan class=\"hljs-keyword\">lambda\u003C/span> x: x[\u003Cspan class=\"hljs-number\">0\u003C/span>])\n            n_best = n_best[:n]\n\n    \u003Cspan class=\"hljs-keyword\">return\u003C/span> n_best\n\u003C/code>\u003C/pre>\u003Cp>With this function, we can finally do what our original goal was, which is to find the best priced tickets. Let&#39;s suppose I want a 10 to 20 day trip between March 1, 2024 and May 31, 2024. Here is the result of that, using our round-trip data as input.\u003C/p>\n\u003Cp>\u003Cimg src=\"/premia_7.png\" alt=\"Air Premia best possible tickets given parameters\">\u003C/p>\n\u003Cp>It seems like we have quite a few options that are all $1,078. Let&#39;s see if we get a better price using our one-way data as input. Rather than buying both tickets together, you would have to purchase them separately.\u003C/p>\n\u003Cp>\u003Cimg src=\"/premia_8.png\" alt=\"Air Premia best possible tickets given parameters with one-way data\">\u003C/p>\n\u003Cp>As it turns out, we can actually get tickets for $57 cheaper by just buying two one-way tickets instead of round-trip tickets. I had always assumed that round-trip tickets would be cheaper than two one-way tickets, but I guess that&#39;s not always the case.\u003C/p>\n\u003Cp>Mission complete. I still would like to plot some data so that we can get a sense for when tickets are cheaper and maybe uncover some other interesting patterns.\u003C/p>\n\u003Cp>Let&#39;s import \u003Ca href=\"https://matplotlib.org/\">matplotlib\u003C/a> so that we can do some data visualization. I&#39;m changing the default pyplot size and DPI to make the output wider and higher resolution.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">\u003Cspan class=\"hljs-keyword\">from\u003C/span> matplotlib \u003Cspan class=\"hljs-keyword\">import\u003C/span> pyplot \u003Cspan class=\"hljs-keyword\">as\u003C/span> plt\nplt.rcParams[\u003Cspan class=\"hljs-string\">&#x27;figure.figsize&#x27;\u003C/span>] = (\u003Cspan class=\"hljs-number\">17\u003C/span>, \u003Cspan class=\"hljs-number\">4\u003C/span>)\nplt.rcParams[\u003Cspan class=\"hljs-string\">&#x27;figure.dpi&#x27;\u003C/span>] = \u003Cspan class=\"hljs-number\">200\u003C/span>\n\u003C/code>\u003C/pre>\u003Cp>Let&#39;s start by showing the prices for different days. I&#39;ll split this into two charts. One for one-way trips and another for round-trips. Some of the bars will overlap one another but you can still see the general pattern, which is what we&#39;re after. \u003Cem>Note: the code for round-trip tickets is almost identical.\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">plt.title(\u003Cspan class=\"hljs-string\">&#x27;USD Cost of One-way Economy Tickets&#x27;\u003C/span>)\nplt.bar(icn_ow[\u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>], icn_ow[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>], color=\u003Cspan class=\"hljs-string\">&#x27;C0&#x27;\u003C/span>, label=\u003Cspan class=\"hljs-string\">&#x27;EWR -&gt; ICN&#x27;\u003C/span>)\nplt.bar(ewr_ow[\u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>], ewr_ow[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>], color=\u003Cspan class=\"hljs-string\">&#x27;C6&#x27;\u003C/span>, label=\u003Cspan class=\"hljs-string\">&#x27;ICN -&gt; EWR&#x27;\u003C/span>)\nplt.legend()\nplt.show()\n\u003C/code>\u003C/pre>\u003Cp>\u003Cimg src=\"/premia_5.png\" alt=\"Air Premia USD Cost of One-way Economy Tickets\">\n\u003Cimg src=\"/premia_6.png\" alt=\"Air Premia USD Cost of Round-trip Economy Tickets\">\u003C/p>\n\u003Cp>Let&#39;s check out what the price difference between one-way and round-trip tickets for the same flight is. We will use the following code which computes \u003Ccode>one way cost - round trip cost\u003C/code>. If this number is positive, that means one-way costs more. If it&#39;s negative, round-trip costs more. \u003Cem>Note: the code for tickets to Newark is almost identical.\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">plt.title(\u003Cspan class=\"hljs-string\">&#x27;USD Price Difference Between One-way and Round-trip Tickets to Incheon&#x27;\u003C/span>)\nplt.bar(icn_ow[\u003Cspan class=\"hljs-string\">&#x27;date&#x27;\u003C/span>], icn_ow[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>] - icn_rt[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>], color=\u003Cspan class=\"hljs-string\">&#x27;C0&#x27;\u003C/span>)\nplt.show()\n\u003C/code>\u003C/pre>\u003Cp>\u003Cimg src=\"/premia_9.png\" alt=\"Air Premia USD Price Difference Between One-way and Round-trip Tickets to Incheon\">\n\u003Cimg src=\"/premia_10.png\" alt=\"Air Premia USD Price Difference Between One-way and Round-trip Tickets to Newark\">\u003C/p>\n\u003Cp>Well now that we have a graphical understanding of the price difference, let&#39;s get a numerical sense for it by taking the mean of the differences.\u003C/p>\n\u003Cpre>\u003Ccode class=\"hljs language-py\">(icn_ow[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>] - icn_rt[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>]).mean(), (ewr_ow[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>] - ewr_rt[\u003Cspan class=\"hljs-string\">&#x27;total&#x27;\u003C/span>]).mean()\n\u003C/code>\u003C/pre>\u003Cp>The result of this is about \u003Ccode>(104.19, -137.54)\u003C/code>. This means that on average, you are saving $104.19 on the tickets to your location by buying round-trip, but you are losing $138.54 on the return tickets. A pair of round-trip tickets is about $33.35 more expensive than two one-way tickets.\u003C/p>\n\u003Ch2>Conclusion\u003C/h2>\n\u003Cp>Congratulations if you&#39;ve made it this far. You must really like data scraping. I hope you&#39;ve enjoyed and that you can take the data and create your own visualizations. As an aside, I did check if there was any price difference between currencies, but they all came out to about the same when converted to USD. Good luck and happy coding.\u003C/p>\n",title:"Finding Cheap Flight Tickets With Python",date:1706727822114,tags:["data","python","scraping"]},"uses":{"params":["id"]}}];

					Promise.all([
						import("../../_app/immutable/entry/start.7108e1ec.js"),
						import("../../_app/immutable/entry/app.9590000c.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
